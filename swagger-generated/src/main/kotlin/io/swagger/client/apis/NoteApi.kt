/**
 * Torrow API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import net.torrow.api.models.DeleteResponse
import net.torrow.api.models.ExcludeFromGroupsReq
import net.torrow.api.models.ExcludeReq
import net.torrow.api.models.ExcludeResp
import net.torrow.api.models.FeedbackOptions
import net.torrow.api.models.FileInfo
import net.torrow.api.models.GetParticipationCountResp
import net.torrow.api.models.GetShareItemSessionReq
import net.torrow.api.models.GroupStatus
import net.torrow.api.models.IncludeExcludeResp
import net.torrow.api.models.IncludeForUserReq
import net.torrow.api.models.IncludeToGroupsReq
import net.torrow.api.models.IncludeToParentReq
import net.torrow.api.models.ItemViewSortCondition
import net.torrow.api.models.NoteItem
import net.torrow.api.models.NotificationWay
import net.torrow.api.models.ObjectInfo
import net.torrow.api.models.OperationType
import net.torrow.api.models.ParticipantState
import net.torrow.api.models.ParticipantType
import net.torrow.api.models.ParticipantView
import net.torrow.api.models.Participation
import net.torrow.api.models.ParticipationResp
import net.torrow.api.models.PersonalReminder
import net.torrow.api.models.PersonalSolutionData
import net.torrow.api.models.PutUrlResp
import net.torrow.api.models.SaveItemToMindMapReq
import net.torrow.api.models.SendLinkOfItemReq
import net.torrow.api.models.SendLinkOfItemResp
import net.torrow.api.models.SetGroupItemReq
import net.torrow.api.models.ShareItemReq
import net.torrow.api.models.SolutionData
import net.torrow.api.models.TorrowItem
import net.torrow.api.models.TorrowObject
import net.torrow.api.models.TorrowObjectType
import net.torrow.api.models.UnsetGroupItemReq
import net.torrow.api.models.UpdateFileIdResp
import net.torrow.api.models.UpdateItemGroupsReq
import net.torrow.api.models.UpdateMasterInfoReq
import net.torrow.api.models.UpdatePersonalListOrderReq
import net.torrow.api.models.UpdatePersonalListOrderResp

import io.swagger.client.infrastructure.*

class NoteApi(basePath: kotlin.String = "/") : ApiClient(basePath) {

    /**
     * 
     * 
     * @param body  (optional)
     * @return ExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesExcludeFromgroupsPut(body: ExcludeFromGroupsReq? = null): ExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/exclude/fromgroups"
        )
        val response = request<ExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @return IncludeExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesIncludeTogroupsPut(body: IncludeToGroupsReq? = null): IncludeExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/include/togroups"
        )
        val response = request<IncludeExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as IncludeExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesItemIdAliasPut(itemId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{itemId}/alias".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param reasonId  (optional)
     * @param reasonNote  (optional)
     * @param language  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesItemIdBlockPost(itemId: kotlin.String, reasonId: kotlin.Int? = null, reasonNote: kotlin.String? = null, language: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowItem {
        val localVariableQuery: MultiValueMap = mapOf("reasonId" to listOf("$reasonId"), "reasonNote" to listOf("$reasonNote"), "language" to listOf("$language"), "versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/notes/{itemId}/block".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<TorrowItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesItemIdLastusagetimePut(itemId: kotlin.String, body: java.time.LocalDateTime? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{itemId}/lastusagetime".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesItemIdNotificationwaylistPut(itemId: kotlin.String, body: kotlin.Array<NotificationWay>? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{itemId}/notificationwaylist".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesItemIdOfflinablePut(itemId: kotlin.String, body: kotlin.Boolean? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{itemId}/offlinable".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesItemIdParticipationProfilePut(itemId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{itemId}/participation/profile".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesItemIdPersonalsolutiondataPut(itemId: kotlin.String, body: PersonalSolutionData? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{itemId}/personalsolutiondata".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesItemIdRemindersPut(itemId: kotlin.String, body: kotlin.Array<PersonalReminder>? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{itemId}/reminders".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @return SendLinkOfItemResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesItemIdSendlinkPut(itemId: kotlin.String, body: SendLinkOfItemReq? = null): SendLinkOfItemResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{itemId}/sendlink".replace("{" + "itemId" + "}", "$itemId")
        )
        val response = request<SendLinkOfItemResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as SendLinkOfItemResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesItemIdUnblockPost(itemId: kotlin.String, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowItem {
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/notes/{itemId}/unblock".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<TorrowItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesItemIdUniquenamePut(itemId: kotlin.String, body: kotlin.String? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{itemId}/uniquename".replace("{" + "itemId" + "}", "$itemId")
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param parentId  
     * @param body  (optional)
     * @return ExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesParentIdExcludeFromuserPut(parentId: kotlin.String, body: ExcludeReq? = null): ExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{parentId}/exclude/fromuser".replace("{" + "parentId" + "}", "$parentId")
        )
        val response = request<ExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param parentId  
     * @param body  (optional)
     * @return ExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesParentIdExcludeItemsPut(parentId: kotlin.String, body: ExcludeReq? = null): ExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{parentId}/exclude/items".replace("{" + "parentId" + "}", "$parentId")
        )
        val response = request<ExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param parentId  
     * @param body  (optional)
     * @return IncludeExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesParentIdIncludeForuserPut(parentId: kotlin.String, body: IncludeForUserReq? = null): IncludeExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{parentId}/include/foruser".replace("{" + "parentId" + "}", "$parentId")
        )
        val response = request<IncludeExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as IncludeExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param parentId  
     * @param body  (optional)
     * @return IncludeExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesParentIdIncludeItemsPut(parentId: kotlin.String, body: IncludeToParentReq? = null): IncludeExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{parentId}/include/items".replace("{" + "parentId" + "}", "$parentId")
        )
        val response = request<IncludeExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as IncludeExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @param profileId  (optional)
     * @param onlyWithEmptyProfile  (optional)
     * @param participantStateList  (optional)
     * @param participantTypeList  (optional)
     * @return kotlin.Array<NoteItem>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesPersonallistGet(take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null, profileId: kotlin.String? = null, onlyWithEmptyProfile: kotlin.Boolean? = null, participantStateList: kotlin.Array<ParticipantState>? = null, participantTypeList: kotlin.Array<ParticipantType>? = null): kotlin.Array<NoteItem> {
        val localVariableQuery: MultiValueMap = mapOf("take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"), "profileId" to listOf("$profileId"), "onlyWithEmptyProfile" to listOf("$onlyWithEmptyProfile"), "participantStateList" to toMultiValue(participantStateList!!.toList(), "multi"), "participantTypeList" to toMultiValue(participantTypeList!!.toList(), "multi"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/notes/personallist", query = localVariableQuery
        )
        val response = request<kotlin.Array<NoteItem>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<NoteItem>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @return void
     */
    fun apiV1NotesPersonallistItemIdDelete(itemId: kotlin.String): Unit {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/api/v1/notes/personallist/{itemId}".replace("{" + "itemId" + "}", "$itemId")
        )
        val response = request<Any?>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @return UpdatePersonalListOrderResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesPersonallistUpdateorderPost(body: UpdatePersonalListOrderReq? = null): UpdatePersonalListOrderResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/notes/personallist/updateorder"
        )
        val response = request<UpdatePersonalListOrderResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UpdatePersonalListOrderResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @param parentId  (optional)
     * @param profileId  (optional)
     * @return NoteItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesPost(body: NoteItem? = null, parentId: kotlin.String? = null, profileId: kotlin.String? = null): NoteItem {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("parentId" to listOf("$parentId"), "profileId" to listOf("$profileId"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/notes", query = localVariableQuery
        )
        val response = request<NoteItem>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as NoteItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param cascade  (optional)
     * @param withPinnedItems  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return DeleteResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdDelete(torrowId: kotlin.String, cascade: kotlin.Boolean? = null, withPinnedItems: kotlin.Boolean? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): DeleteResponse {
        val localVariableQuery: MultiValueMap = mapOf("cascade" to listOf("$cascade"), "withPinnedItems" to listOf("$withPinnedItems"), "versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/api/v1/notes/{torrowId}".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<DeleteResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as DeleteResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdFeedbacksOptionsPut(torrowId: kotlin.String, body: FeedbackOptions? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/feedbacks/options".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param fileId  (optional)
     * @return FileInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdFileInfoGet(torrowId: kotlin.String, fileId: kotlin.String? = null): FileInfo {
        val localVariableQuery: MultiValueMap = mapOf("fileId" to listOf("$fileId"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/notes/{torrowId}/file/info".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<FileInfo>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param fileId  (optional)
     * @param fileName  (optional)
     * @param fileSize  (optional, default to 0)
     * @return PutUrlResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdFilePuturlGet(torrowId: kotlin.String, fileId: kotlin.String? = null, fileName: kotlin.String? = null, fileSize: kotlin.Long? = null): PutUrlResp {
        val localVariableQuery: MultiValueMap = mapOf("fileId" to listOf("$fileId"), "fileName" to listOf("$fileName"), "fileSize" to listOf("$fileSize"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/notes/{torrowId}/file/puturl".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<PutUrlResp>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PutUrlResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param versionToCheck  (optional, default to 0)
     * @param includeDeleted  (optional, default to false)
     * @param includeChildTypes  (optional, default to false)
     * @return NoteItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdGet(torrowId: kotlin.String, versionToCheck: kotlin.Int? = null, includeDeleted: kotlin.Boolean? = null, includeChildTypes: kotlin.Boolean? = null): NoteItem {
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "includeDeleted" to listOf("$includeDeleted"), "includeChildTypes" to listOf("$includeChildTypes"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/notes/{torrowId}".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<NoteItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as NoteItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param itemType  (optional)
     * @param minParticipantType  (optional)
     * @param operationType  (optional)
     * @param recursionDepth  (optional, default to 0)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @return kotlin.Array<TorrowItem>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdGroupListGet(torrowId: kotlin.String, itemType: TorrowObjectType? = null, minParticipantType: ParticipantType? = null, operationType: OperationType? = null, recursionDepth: kotlin.Int? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null): kotlin.Array<TorrowItem> {
        val localVariableQuery: MultiValueMap = mapOf("itemType" to listOf("$itemType"), "minParticipantType" to listOf("$minParticipantType"), "operationType" to listOf("$operationType"), "recursionDepth" to listOf("$recursionDepth"), "take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/notes/{torrowId}/group/list".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<TorrowItem>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<TorrowItem>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return TorrowItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdGroupSetPut(torrowId: kotlin.String, body: SetGroupItemReq? = null): TorrowItem {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/group/set".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<TorrowItem>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return TorrowItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdGroupUnsetPut(torrowId: kotlin.String, body: UnsetGroupItemReq? = null): TorrowItem {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/group/unset".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<TorrowItem>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param parentId  (optional)
     * @param itemType  (optional)
     * @param minParticipantType  (optional)
     * @param operationType  (optional)
     * @param recursionDepth  (optional, default to 0)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @return kotlin.Array<GroupStatus>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdGroupsGet(torrowId: kotlin.String, parentId: kotlin.String? = null, itemType: TorrowObjectType? = null, minParticipantType: ParticipantType? = null, operationType: OperationType? = null, recursionDepth: kotlin.Int? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null): kotlin.Array<GroupStatus> {
        val localVariableQuery: MultiValueMap = mapOf("parentId" to listOf("$parentId"), "itemType" to listOf("$itemType"), "minParticipantType" to listOf("$minParticipantType"), "operationType" to listOf("$operationType"), "recursionDepth" to listOf("$recursionDepth"), "take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/notes/{torrowId}/groups".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<GroupStatus>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<GroupStatus>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return UpdateFileIdResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdImageIdPut(torrowId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): UpdateFileIdResp {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/image/id".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<UpdateFileIdResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UpdateFileIdResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @return FileInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdImageInfoGet(torrowId: kotlin.String): FileInfo {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/notes/{torrowId}/image/info".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<FileInfo>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param fileId  (optional)
     * @param fileName  (optional)
     * @param fileSize  (optional, default to 0)
     * @return PutUrlResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdImagePuturlGet(torrowId: kotlin.String, fileId: kotlin.String? = null, fileName: kotlin.String? = null, fileSize: kotlin.Long? = null): PutUrlResp {
        val localVariableQuery: MultiValueMap = mapOf("fileId" to listOf("$fileId"), "fileName" to listOf("$fileName"), "fileSize" to listOf("$fileSize"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/notes/{torrowId}/image/puturl".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<PutUrlResp>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PutUrlResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdIntegrationsPut(torrowId: kotlin.String, body: kotlin.Array<kotlin.String>? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/integrations".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdMasterinfoPut(torrowId: kotlin.String, body: UpdateMasterInfoReq? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/masterinfo".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @return GetParticipationCountResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdParticipantsAnonymousGet(torrowId: kotlin.String): GetParticipationCountResp {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/notes/{torrowId}/participants/anonymous".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<GetParticipationCountResp>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetParticipationCountResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param participantStateList  (optional)
     * @param participantTypeList  (optional)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @return kotlin.Array<ParticipantView>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdParticipantsGet(torrowId: kotlin.String, participantStateList: kotlin.Array<ParticipantState>? = null, participantTypeList: kotlin.Array<ParticipantType>? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null): kotlin.Array<ParticipantView> {
        val localVariableQuery: MultiValueMap = mapOf("participantStateList" to toMultiValue(participantStateList!!.toList(), "multi"), "participantTypeList" to toMultiValue(participantTypeList!!.toList(), "multi"), "take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/notes/{torrowId}/participants".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<ParticipantView>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ParticipantView>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param participantStateList  (optional)
     * @param participantTypeList  (optional)
     * @return GetParticipationCountResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdParticipantsNonanonymousGet(torrowId: kotlin.String, participantStateList: kotlin.Array<ParticipantState>? = null, participantTypeList: kotlin.Array<ParticipantType>? = null): GetParticipationCountResp {
        val localVariableQuery: MultiValueMap = mapOf("participantStateList" to toMultiValue(participantStateList!!.toList(), "multi"), "participantTypeList" to toMultiValue(participantTypeList!!.toList(), "multi"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/notes/{torrowId}/participants/nonanonymous".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<GetParticipationCountResp>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetParticipationCountResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param userMessage  (optional)
     * @return ParticipationResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdParticipationDeclineaccessPut(torrowId: kotlin.String, body: kotlin.Array<kotlin.String>? = null, userMessage: kotlin.String? = null): ParticipationResp {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("userMessage" to listOf("$userMessage"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/participation/declineaccess".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<ParticipationResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ParticipationResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return ParticipationResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdParticipationGrantaccessPut(torrowId: kotlin.String, body: kotlin.Array<kotlin.String>? = null): ParticipationResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/participation/grantaccess".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<ParticipationResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ParticipationResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param participantProfileId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdParticipationParticipantProfileIdTypePut(torrowId: kotlin.String, participantProfileId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/participation/{participantProfileId}/type".replace("{" + "torrowId" + "}", "$torrowId").replace("{" + "participantProfileId" + "}", "$participantProfileId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return Participation
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdParticipationRejectPut(torrowId: kotlin.String, body: kotlin.String? = null): Participation {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/participation/reject".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<Participation>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Participation
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param userMessage  (optional)
     * @return Participation
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdParticipationRejectofferPut(torrowId: kotlin.String, body: kotlin.String? = null, userMessage: kotlin.String? = null): Participation {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("userMessage" to listOf("$userMessage"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/participation/rejectoffer".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<Participation>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Participation
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param userMessage  (optional)
     * @return Participation
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdParticipationRequestaccessPut(torrowId: kotlin.String, body: kotlin.String? = null, userMessage: kotlin.String? = null): Participation {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("userMessage" to listOf("$userMessage"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/participation/requestaccess".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<Participation>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Participation
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return ParticipationResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdParticipationRevokeofferPut(torrowId: kotlin.String, body: kotlin.Array<kotlin.String>? = null): ParticipationResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/participation/revokeoffer".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<ParticipationResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ParticipationResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @return Participation
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdParticipationRevokerequestPut(torrowId: kotlin.String): Participation {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/participation/revokerequest".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<Participation>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Participation
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return ParticipationResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdParticipationSharePut(torrowId: kotlin.String, body: ShareItemReq? = null): ParticipationResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/participation/share".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<ParticipationResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ParticipationResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdParticipationShareitemlinkPost(torrowId: kotlin.String, body: GetShareItemSessionReq? = null): kotlin.String {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/notes/{torrowId}/participation/shareitemlink".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<kotlin.String>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdPublicityPut(torrowId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/publicity".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param checkVersion  (optional, default to true)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return NoteItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdPut(torrowId: kotlin.String, body: NoteItem? = null, checkVersion: kotlin.Boolean? = null, isNeedAnnouncement: kotlin.Boolean? = null): NoteItem {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("checkVersion" to listOf("$checkVersion"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<NoteItem>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as NoteItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return Participation
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdSavetomindmapPut(torrowId: kotlin.String, body: SaveItemToMindMapReq? = null): Participation {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/savetomindmap".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<Participation>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Participation
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdShorturlPost(torrowId: kotlin.String): kotlin.String {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/notes/{torrowId}/shorturl".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<kotlin.String>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdSolutiondataPut(torrowId: kotlin.String, body: SolutionData? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/solutiondata".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param itemType  (optional)
     * @param text  (optional)
     * @param minParticipantType  (optional)
     * @param operationType  (optional)
     * @param recursionDepth  (optional, default to 0)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @return kotlin.Array<kotlin.String>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdTagsGet(torrowId: kotlin.String, itemType: TorrowObjectType? = null, text: kotlin.String? = null, minParticipantType: ParticipantType? = null, operationType: OperationType? = null, recursionDepth: kotlin.Int? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null): kotlin.Array<kotlin.String> {
        val localVariableQuery: MultiValueMap = mapOf("itemType" to listOf("$itemType"), "text" to listOf("$text"), "minParticipantType" to listOf("$minParticipantType"), "operationType" to listOf("$operationType"), "recursionDepth" to listOf("$recursionDepth"), "take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/notes/{torrowId}/tags".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<kotlin.String>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.String>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdTagsPut(torrowId: kotlin.String, body: kotlin.Array<kotlin.String>? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/tags".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdTorrowaccountIdPut(torrowId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/torrowaccount/id".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param parentId  (optional)
     * @param parentTags  (optional)
     * @param parentAlias  (optional)
     * @param tags  (optional)
     * @param alias  (optional)
     * @param versionToCheck  (optional)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return IncludeExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesTorrowIdUpdategroupsPut(torrowId: kotlin.String, body: kotlin.Array<UpdateItemGroupsReq>? = null, parentId: kotlin.String? = null, parentTags: kotlin.Array<kotlin.String>? = null, parentAlias: kotlin.String? = null, tags: kotlin.Array<kotlin.String>? = null, alias: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): IncludeExcludeResp {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("parentId" to listOf("$parentId"), "parentTags" to toMultiValue(parentTags!!.toList(), "multi"), "parentAlias" to listOf("$parentAlias"), "tags" to toMultiValue(tags!!.toList(), "multi"), "alias" to listOf("$alias"), "versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/notes/{torrowId}/updategroups".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<IncludeExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as IncludeExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param uniquename  
     * @return NoteItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1NotesUniquenameUniquenameGet(uniquename: kotlin.String): NoteItem {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/notes/uniquename/{uniquename}".replace("{" + "uniquename" + "}", "$uniquename")
        )
        val response = request<NoteItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as NoteItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
