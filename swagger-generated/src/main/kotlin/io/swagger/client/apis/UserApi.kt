/**
 * Torrow API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import net.torrow.api.models.Account
import net.torrow.api.models.AddProfileResp
import net.torrow.api.models.ContactItem
import net.torrow.api.models.DeleteResponse
import net.torrow.api.models.DeletingCompleteResp
import net.torrow.api.models.DeliveryChannel
import net.torrow.api.models.DeviceInfo
import net.torrow.api.models.DeviceSettingsInfo
import net.torrow.api.models.DeviceType
import net.torrow.api.models.ItemViewSortCondition
import net.torrow.api.models.LoyaltyCardItem
import net.torrow.api.models.NotificationWay
import net.torrow.api.models.ProfileListResp
import net.torrow.api.models.ProfileProperties
import net.torrow.api.models.RegisterUserForAccountResp
import net.torrow.api.models.RegistrationUserInfo
import net.torrow.api.models.RemoveProfileResp
import net.torrow.api.models.TimetableCase
import net.torrow.api.models.TimetableDetailsVisibility
import net.torrow.api.models.TimetableFilter
import net.torrow.api.models.TorrowObject
import net.torrow.api.models.UpdateProfilePropertiesResp
import net.torrow.api.models.UserCalendar
import net.torrow.api.models.UserDeletingInitResp
import net.torrow.api.models.UserDeliveryWay
import net.torrow.api.models.UserSettingsInfo

import io.swagger.client.infrastructure.*

class UserApi(basePath: kotlin.String = "/") : ApiClient(basePath) {

    /**
     * 
     * 
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @return kotlin.Array<Account>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserAccountsGet(take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null): kotlin.Array<Account> {
        val localVariableQuery: MultiValueMap = mapOf("take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/user/accounts", query = localVariableQuery
        )
        val response = request<kotlin.Array<Account>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Account>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @return kotlin.Array<UserCalendar>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserCalendarsGet(): kotlin.Array<UserCalendar> {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/user/calendars"
        )
        val response = request<kotlin.Array<UserCalendar>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<UserCalendar>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserCalendarsUpdatePut(body: kotlin.Array<UserCalendar>? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/user/calendars/update"
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @return kotlin.Long
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserCountGet(): kotlin.Long {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/user/count"
        )
        val response = request<kotlin.Long>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Long
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @return kotlin.Array<NotificationWay>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserDefaultnotificationwaysGet(): kotlin.Array<NotificationWay> {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/user/defaultnotificationways"
        )
        val response = request<kotlin.Array<NotificationWay>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<NotificationWay>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserDefaultnotificationwaysPut(body: kotlin.Array<NotificationWay>? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/user/defaultnotificationways", query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @return ContactItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserDefaultprofileGet(): ContactItem {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/user/defaultprofile"
        )
        val response = request<ContactItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ContactItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @return AddProfileResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserDefaultprofilePost(body: ContactItem? = null): AddProfileResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/user/defaultprofile"
        )
        val response = request<AddProfileResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AddProfileResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @return AddProfileResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserDefaultprofilePut(body: kotlin.String? = null): AddProfileResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/user/defaultprofile"
        )
        val response = request<AddProfileResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AddProfileResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param sessionId  
     * @param body  (optional)
     * @return DeletingCompleteResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserDeletingcompleteSessionIdDelete(sessionId: kotlin.String, body: kotlin.String? = null): DeletingCompleteResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/api/v1/user/deletingcomplete/{sessionId}".replace("{" + "sessionId" + "}", "$sessionId")
        )
        val response = request<DeletingCompleteResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as DeletingCompleteResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @return UserDeletingInitResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserDeletinginitDelete(): UserDeletingInitResp {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/api/v1/user/deletinginit"
        )
        val response = request<UserDeletingInitResp>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UserDeletingInitResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param deliveryChannelList  (optional)
     * @return kotlin.Array<UserDeliveryWay>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserDeliverywaysGet(deliveryChannelList: kotlin.Array<DeliveryChannel>? = null): kotlin.Array<UserDeliveryWay> {
        val localVariableQuery: MultiValueMap = mapOf("deliveryChannelList" to toMultiValue(deliveryChannelList!!.toList(), "multi"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/user/deliveryways", query = localVariableQuery
        )
        val response = request<kotlin.Array<UserDeliveryWay>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<UserDeliveryWay>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param deviceId  
     * @return DeleteResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserDevicesDeviceIdDelete(deviceId: kotlin.String): DeleteResponse {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/api/v1/user/devices/{deviceId}".replace("{" + "deviceId" + "}", "$deviceId")
        )
        val response = request<DeleteResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as DeleteResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param deviceId  
     * @return DeviceSettingsInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserDevicesDeviceIdSettingsGet(deviceId: kotlin.String): DeviceSettingsInfo {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/user/devices/{deviceId}/settings".replace("{" + "deviceId" + "}", "$deviceId")
        )
        val response = request<DeviceSettingsInfo>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as DeviceSettingsInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param deviceId  
     * @param settings  (optional)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserDevicesDeviceIdSettingsPut(deviceId: kotlin.String, settings: kotlin.String? = null): TorrowObject {
        val localVariableQuery: MultiValueMap = mapOf("settings" to listOf("$settings"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/user/devices/{deviceId}/settings".replace("{" + "deviceId" + "}", "$deviceId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param deviceTypes  (optional)
     * @return kotlin.Array<DeviceInfo>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserDevicesGet(deviceTypes: kotlin.Array<DeviceType>? = null): kotlin.Array<DeviceInfo> {
        val localVariableQuery: MultiValueMap = mapOf("deviceTypes" to toMultiValue(deviceTypes!!.toList(), "multi"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/user/devices", query = localVariableQuery
        )
        val response = request<kotlin.Array<DeviceInfo>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<DeviceInfo>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @return LoyaltyCardItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserLoyaltycardGet(): LoyaltyCardItem {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/user/loyaltycard"
        )
        val response = request<LoyaltyCardItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as LoyaltyCardItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param profileId  (optional)
     * @param placeId  (optional)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserPlacePut(profileId: kotlin.String? = null, placeId: kotlin.Int? = null): TorrowObject {
        val localVariableQuery: MultiValueMap = mapOf("profileId" to listOf("$profileId"), "placeId" to listOf("$placeId"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/user/place", query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @return ProfileListResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserProfilesGet(): ProfileListResp {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/user/profiles"
        )
        val response = request<ProfileListResp>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ProfileListResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @return AddProfileResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserProfilesPost(body: ContactItem? = null): AddProfileResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/user/profiles"
        )
        val response = request<AddProfileResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AddProfileResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param profileId  
     * @return RemoveProfileResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserProfilesProfileIdDelete(profileId: kotlin.String): RemoveProfileResp {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/api/v1/user/profiles/{profileId}".replace("{" + "profileId" + "}", "$profileId")
        )
        val response = request<RemoveProfileResp>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as RemoveProfileResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param profileId  
     * @param body  (optional)
     * @return UpdateProfilePropertiesResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserProfilesProfileIdProfilepropertiesPut(profileId: kotlin.String, body: ProfileProperties? = null): UpdateProfilePropertiesResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/user/profiles/{profileId}/profileproperties".replace("{" + "profileId" + "}", "$profileId")
        )
        val response = request<UpdateProfilePropertiesResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UpdateProfilePropertiesResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @return AddProfileResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserProfilesPut(body: kotlin.String? = null): AddProfileResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/user/profiles"
        )
        val response = request<AddProfileResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AddProfileResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @param templateContactId  (optional)
     * @param inviterProfileId  (optional)
     * @return RegisterUserForAccountResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserRegisterPost(body: RegistrationUserInfo? = null, templateContactId: kotlin.String? = null, inviterProfileId: kotlin.String? = null): RegisterUserForAccountResp {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("templateContactId" to listOf("$templateContactId"), "inviterProfileId" to listOf("$inviterProfileId"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/user/register", query = localVariableQuery
        )
        val response = request<RegisterUserForAccountResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as RegisterUserForAccountResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @return UserSettingsInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserSettingsGet(): UserSettingsInfo {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/user/settings"
        )
        val response = request<UserSettingsInfo>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UserSettingsInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserSettingsUpdatePut(body: UserSettingsInfo? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/user/settings/update"
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @param visibility  (optional)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @return kotlin.Array<TimetableCase>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1UserTimetablePut(body: TimetableFilter? = null, visibility: TimetableDetailsVisibility? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null): kotlin.Array<TimetableCase> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("visibility" to listOf("$visibility"), "take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/user/timetable", query = localVariableQuery
        )
        val response = request<kotlin.Array<TimetableCase>>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<TimetableCase>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
