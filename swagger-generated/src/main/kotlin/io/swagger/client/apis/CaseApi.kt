/**
 * Torrow API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import net.torrow.api.models.AgentType
import net.torrow.api.models.ApproveCaseParticipationReq
import net.torrow.api.models.AvailabilityTime
import net.torrow.api.models.BookResourcesForMeReq
import net.torrow.api.models.BookResourcesForOthersReq
import net.torrow.api.models.BookResourcesReq
import net.torrow.api.models.CancelCaseParticipationReq
import net.torrow.api.models.CancelMyCaseParticipationReq
import net.torrow.api.models.CancelOtherCaseParticipationReq
import net.torrow.api.models.CaseItem
import net.torrow.api.models.CaseParticipant
import net.torrow.api.models.CaseParticipantFields
import net.torrow.api.models.CaseParticipantState
import net.torrow.api.models.CaseParticipantType
import net.torrow.api.models.CaseParticipantView
import net.torrow.api.models.ChangeMoneyReceiveReq
import net.torrow.api.models.CheckInOtherReq
import net.torrow.api.models.CheckInProps
import net.torrow.api.models.CheckInReq
import net.torrow.api.models.CreateCaseReq
import net.torrow.api.models.DeleteResponse
import net.torrow.api.models.ExcludeFromGroupsReq
import net.torrow.api.models.ExcludeReq
import net.torrow.api.models.ExcludeResp
import net.torrow.api.models.FeedbackOptions
import net.torrow.api.models.FileInfo
import net.torrow.api.models.GenerateSecurityTokenReq
import net.torrow.api.models.GenerateSecurityTokenResp
import net.torrow.api.models.GetCaseParticipationCountResp
import net.torrow.api.models.GetParticipationCountResp
import net.torrow.api.models.GetShareItemSessionReq
import net.torrow.api.models.GroupStatus
import net.torrow.api.models.IncludeExcludeResp
import net.torrow.api.models.IncludeForUserReq
import net.torrow.api.models.IncludeToGroupsReq
import net.torrow.api.models.IncludeToParentReq
import net.torrow.api.models.ItemViewSortCondition
import net.torrow.api.models.NotificationWay
import net.torrow.api.models.ObjectInfo
import net.torrow.api.models.OperationType
import net.torrow.api.models.ParticipantState
import net.torrow.api.models.ParticipantType
import net.torrow.api.models.ParticipantView
import net.torrow.api.models.Participation
import net.torrow.api.models.ParticipationResp
import net.torrow.api.models.PatchCaseReq
import net.torrow.api.models.PersonalReminder
import net.torrow.api.models.PersonalSolutionData
import net.torrow.api.models.PutUrlResp
import net.torrow.api.models.ResourceView
import net.torrow.api.models.SaveItemToMindMapReq
import net.torrow.api.models.SendLinkOfItemReq
import net.torrow.api.models.SendLinkOfItemResp
import net.torrow.api.models.SetGroupItemReq
import net.torrow.api.models.ShareItemReq
import net.torrow.api.models.SolutionData
import net.torrow.api.models.TorrowItem
import net.torrow.api.models.TorrowObject
import net.torrow.api.models.TorrowObjectType
import net.torrow.api.models.UnsetGroupItemReq
import net.torrow.api.models.UpdateFileIdResp
import net.torrow.api.models.UpdateItemGroupsReq
import net.torrow.api.models.UpdateMasterInfoReq
import net.torrow.api.models.UpdatePersonalListOrderReq
import net.torrow.api.models.UpdatePersonalListOrderResp

import io.swagger.client.infrastructure.*

class CaseApi(basePath: kotlin.String = "/") : ApiClient(basePath) {

    /**
     * 
     * 
     * @param body  (optional)
     * @return ExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesExcludeFromgroupsPut(body: ExcludeFromGroupsReq? = null): ExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/exclude/fromgroups"
        )
        val response = request<ExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @return IncludeExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesIncludeTogroupsPut(body: IncludeToGroupsReq? = null): IncludeExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/include/togroups"
        )
        val response = request<IncludeExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as IncludeExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesItemIdAliasPut(itemId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{itemId}/alias".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param reasonId  (optional)
     * @param reasonNote  (optional)
     * @param language  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesItemIdBlockPost(itemId: kotlin.String, reasonId: kotlin.Int? = null, reasonNote: kotlin.String? = null, language: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowItem {
        val localVariableQuery: MultiValueMap = mapOf("reasonId" to listOf("$reasonId"), "reasonNote" to listOf("$reasonNote"), "language" to listOf("$language"), "versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/cases/{itemId}/block".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<TorrowItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesItemIdLastusagetimePut(itemId: kotlin.String, body: java.time.LocalDateTime? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{itemId}/lastusagetime".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesItemIdNotificationwaylistPut(itemId: kotlin.String, body: kotlin.Array<NotificationWay>? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{itemId}/notificationwaylist".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesItemIdOfflinablePut(itemId: kotlin.String, body: kotlin.Boolean? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{itemId}/offlinable".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesItemIdParticipationProfilePut(itemId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{itemId}/participation/profile".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesItemIdPersonalsolutiondataPut(itemId: kotlin.String, body: PersonalSolutionData? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{itemId}/personalsolutiondata".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesItemIdRemindersPut(itemId: kotlin.String, body: kotlin.Array<PersonalReminder>? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{itemId}/reminders".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @return SendLinkOfItemResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesItemIdSendlinkPut(itemId: kotlin.String, body: SendLinkOfItemReq? = null): SendLinkOfItemResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{itemId}/sendlink".replace("{" + "itemId" + "}", "$itemId")
        )
        val response = request<SendLinkOfItemResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as SendLinkOfItemResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesItemIdUnblockPost(itemId: kotlin.String, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowItem {
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/cases/{itemId}/unblock".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<TorrowItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesItemIdUniquenamePut(itemId: kotlin.String, body: kotlin.String? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{itemId}/uniquename".replace("{" + "itemId" + "}", "$itemId")
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param parentId  
     * @param body  (optional)
     * @return ExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesParentIdExcludeFromuserPut(parentId: kotlin.String, body: ExcludeReq? = null): ExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{parentId}/exclude/fromuser".replace("{" + "parentId" + "}", "$parentId")
        )
        val response = request<ExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param parentId  
     * @param body  (optional)
     * @return ExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesParentIdExcludeItemsPut(parentId: kotlin.String, body: ExcludeReq? = null): ExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{parentId}/exclude/items".replace("{" + "parentId" + "}", "$parentId")
        )
        val response = request<ExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param parentId  
     * @param body  (optional)
     * @return IncludeExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesParentIdIncludeForuserPut(parentId: kotlin.String, body: IncludeForUserReq? = null): IncludeExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{parentId}/include/foruser".replace("{" + "parentId" + "}", "$parentId")
        )
        val response = request<IncludeExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as IncludeExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param parentId  
     * @param body  (optional)
     * @return IncludeExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesParentIdIncludeItemsPut(parentId: kotlin.String, body: IncludeToParentReq? = null): IncludeExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{parentId}/include/items".replace("{" + "parentId" + "}", "$parentId")
        )
        val response = request<IncludeExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as IncludeExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param profileId  (optional)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @param onlyWithEmptyProfile  (optional)
     * @param participantStateList  (optional)
     * @param participantTypeList  (optional)
     * @return kotlin.Array<CaseItem>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesPersonallistGet(profileId: kotlin.String? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null, onlyWithEmptyProfile: kotlin.Boolean? = null, participantStateList: kotlin.Array<ParticipantState>? = null, participantTypeList: kotlin.Array<ParticipantType>? = null): kotlin.Array<CaseItem> {
        val localVariableQuery: MultiValueMap = mapOf("profileId" to listOf("$profileId"), "take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"), "onlyWithEmptyProfile" to listOf("$onlyWithEmptyProfile"), "participantStateList" to toMultiValue(participantStateList!!.toList(), "multi"), "participantTypeList" to toMultiValue(participantTypeList!!.toList(), "multi"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/cases/personallist", query = localVariableQuery
        )
        val response = request<kotlin.Array<CaseItem>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<CaseItem>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @return void
     */
    fun apiV1CasesPersonallistItemIdDelete(itemId: kotlin.String): Unit {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/api/v1/cases/personallist/{itemId}".replace("{" + "itemId" + "}", "$itemId")
        )
        val response = request<Any?>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @return UpdatePersonalListOrderResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesPersonallistUpdateorderPost(body: UpdatePersonalListOrderReq? = null): UpdatePersonalListOrderResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/cases/personallist/updateorder"
        )
        val response = request<UpdatePersonalListOrderResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UpdatePersonalListOrderResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @param parentId  (optional)
     * @param profileId  (optional)
     * @param isNeedToCheckInMySelf  (optional, default to false)
     * @param availabilityTime  (optional)
     * @param roadTime  (optional)
     * @param calendarId  (optional)
     * @param caseParticipantType  (optional)
     * @return CaseItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesPost(body: CaseItem? = null, parentId: kotlin.String? = null, profileId: kotlin.String? = null, isNeedToCheckInMySelf: kotlin.Boolean? = null, availabilityTime: AvailabilityTime? = null, roadTime: kotlin.Int? = null, calendarId: kotlin.String? = null, caseParticipantType: CaseParticipantType? = null): CaseItem {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("parentId" to listOf("$parentId"), "profileId" to listOf("$profileId"), "isNeedToCheckInMySelf" to listOf("$isNeedToCheckInMySelf"), "availabilityTime" to listOf("$availabilityTime"), "roadTime" to listOf("$roadTime"), "calendarId" to listOf("$calendarId"), "caseParticipantType" to listOf("$caseParticipantType"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/cases", query = localVariableQuery
        )
        val response = request<CaseItem>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CaseItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @param parentId  (optional)
     * @param profileId  (optional)
     * @return CaseItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesPut(body: CreateCaseReq? = null, parentId: kotlin.String? = null, profileId: kotlin.String? = null): CaseItem {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("parentId" to listOf("$parentId"), "profileId" to listOf("$profileId"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases", query = localVariableQuery
        )
        val response = request<CaseItem>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CaseItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param profileId  (optional)
     * @param userMessage  (optional)
     * @return CaseItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdAcceptPost(torrowId: kotlin.String, profileId: kotlin.String? = null, userMessage: kotlin.String? = null): CaseItem {
        val localVariableQuery: MultiValueMap = mapOf("profileId" to listOf("$profileId"), "userMessage" to listOf("$userMessage"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/cases/{torrowId}/accept".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<CaseItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CaseItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param profileId  (optional)
     * @param userMessage  (optional)
     * @param securityToken  (optional)
     * @return CaseItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdCancelPost(torrowId: kotlin.String, profileId: kotlin.String? = null, userMessage: kotlin.String? = null, securityToken: kotlin.String? = null): CaseItem {
        val localVariableQuery: MultiValueMap = mapOf("profileId" to listOf("$profileId"), "userMessage" to listOf("$userMessage"), "securityToken" to listOf("$securityToken"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/cases/{torrowId}/cancel".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<CaseItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CaseItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return kotlin.Array<CaseParticipant>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdCaseparticipantsApprovemoneyreceivePut(torrowId: kotlin.String, body: ChangeMoneyReceiveReq? = null): kotlin.Array<CaseParticipant> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/caseparticipants/approvemoneyreceive".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<kotlin.Array<CaseParticipant>>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<CaseParticipant>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param caseParticipantId  
     * @param body  (optional)
     * @param userMessage  (optional)
     * @param versionToCheck  (optional)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return CaseParticipant
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdCaseparticipantsCaseParticipantIdFieldsPatch(torrowId: kotlin.String, caseParticipantId: kotlin.String, body: CaseParticipantFields? = null, userMessage: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): CaseParticipant {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("userMessage" to listOf("$userMessage"), "versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PATCH,
                "/api/v1/cases/{torrowId}/caseparticipants/{caseParticipantId}/fields".replace("{" + "torrowId" + "}", "$torrowId").replace("{" + "caseParticipantId" + "}", "$caseParticipantId"), query = localVariableQuery
        )
        val response = request<CaseParticipant>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CaseParticipant
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param caseParticipantId  
     * @return CaseParticipantView
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdCaseparticipantsCaseParticipantIdGet(torrowId: kotlin.String, caseParticipantId: kotlin.String): CaseParticipantView {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/cases/{torrowId}/caseparticipants/{caseParticipantId}".replace("{" + "torrowId" + "}", "$torrowId").replace("{" + "caseParticipantId" + "}", "$caseParticipantId")
        )
        val response = request<CaseParticipantView>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CaseParticipantView
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param caseParticipantStateList  (optional)
     * @param caseParticipantTypeList  (optional)
     * @param agentType  (optional)
     * @return GetCaseParticipationCountResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdCaseparticipantsCountGet(torrowId: kotlin.String, caseParticipantStateList: kotlin.Array<CaseParticipantState>? = null, caseParticipantTypeList: kotlin.Array<CaseParticipantType>? = null, agentType: AgentType? = null): GetCaseParticipationCountResp {
        val localVariableQuery: MultiValueMap = mapOf("caseParticipantStateList" to toMultiValue(caseParticipantStateList!!.toList(), "multi"), "caseParticipantTypeList" to toMultiValue(caseParticipantTypeList!!.toList(), "multi"), "agentType" to listOf("$agentType"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/cases/{torrowId}/caseparticipants/count".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<GetCaseParticipationCountResp>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetCaseParticipationCountResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param caseParticipantStateList  (optional)
     * @param caseParticipantTypeList  (optional)
     * @param agentType  (optional)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @return kotlin.Array<CaseParticipantView>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdCaseparticipantsGet(torrowId: kotlin.String, caseParticipantStateList: kotlin.Array<CaseParticipantState>? = null, caseParticipantTypeList: kotlin.Array<CaseParticipantType>? = null, agentType: AgentType? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null): kotlin.Array<CaseParticipantView> {
        val localVariableQuery: MultiValueMap = mapOf("caseParticipantStateList" to toMultiValue(caseParticipantStateList!!.toList(), "multi"), "caseParticipantTypeList" to toMultiValue(caseParticipantTypeList!!.toList(), "multi"), "agentType" to listOf("$agentType"), "take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/cases/{torrowId}/caseparticipants".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<CaseParticipantView>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<CaseParticipantView>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param caseParticipantStateList  (optional)
     * @param caseParticipantTypeList  (optional)
     * @param agentType  (optional)
     * @return GetCaseParticipationCountResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdCaseparticipantsNonanonymousGet(torrowId: kotlin.String, caseParticipantStateList: kotlin.Array<CaseParticipantState>? = null, caseParticipantTypeList: kotlin.Array<CaseParticipantType>? = null, agentType: AgentType? = null): GetCaseParticipationCountResp {
        val localVariableQuery: MultiValueMap = mapOf("caseParticipantStateList" to toMultiValue(caseParticipantStateList!!.toList(), "multi"), "caseParticipantTypeList" to toMultiValue(caseParticipantTypeList!!.toList(), "multi"), "agentType" to listOf("$agentType"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/cases/{torrowId}/caseparticipants/nonanonymous".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<GetCaseParticipationCountResp>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetCaseParticipationCountResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param profileId  
     * @param userMessage  (optional)
     * @param isNeedAnnouncement  (optional, default to true)
     * @param versionToCheck  (optional)
     * @param securityToken  (optional)
     * @return CaseParticipant
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdCaseparticipantsProfileIdConfirmparticipationPatch(torrowId: kotlin.String, profileId: kotlin.String, userMessage: kotlin.String? = null, isNeedAnnouncement: kotlin.Boolean? = null, versionToCheck: kotlin.Int? = null, securityToken: kotlin.String? = null): CaseParticipant {
        val localVariableQuery: MultiValueMap = mapOf("userMessage" to listOf("$userMessage"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"), "versionToCheck" to listOf("$versionToCheck"), "securityToken" to listOf("$securityToken"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PATCH,
                "/api/v1/cases/{torrowId}/caseparticipants/{profileId}/confirmparticipation".replace("{" + "torrowId" + "}", "$torrowId").replace("{" + "profileId" + "}", "$profileId"), query = localVariableQuery
        )
        val response = request<CaseParticipant>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CaseParticipant
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return kotlin.Array<CaseParticipant>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdCaseparticipantsRejectmoneyreceivePut(torrowId: kotlin.String, body: ChangeMoneyReceiveReq? = null): kotlin.Array<CaseParticipant> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/caseparticipants/rejectmoneyreceive".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<kotlin.Array<CaseParticipant>>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<CaseParticipant>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return kotlin.Array<CaseParticipant>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdCaseparticipationApprovecaseparticipationPut(torrowId: kotlin.String, body: ApproveCaseParticipationReq? = null): kotlin.Array<CaseParticipant> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/caseparticipation/approvecaseparticipation".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<kotlin.Array<CaseParticipant>>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<CaseParticipant>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return kotlin.Array<CaseParticipant>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdCaseparticipationBookresourcesPut(torrowId: kotlin.String, body: BookResourcesReq? = null): kotlin.Array<CaseParticipant> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/caseparticipation/bookresources".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<kotlin.Array<CaseParticipant>>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<CaseParticipant>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param profileId  (optional)
     * @return CaseParticipant
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdCaseparticipationBookresourcesformePut(torrowId: kotlin.String, body: BookResourcesForMeReq? = null, profileId: kotlin.String? = null): CaseParticipant {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("profileId" to listOf("$profileId"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/caseparticipation/bookresourcesforme".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<CaseParticipant>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CaseParticipant
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return kotlin.Array<CaseParticipant>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdCaseparticipationBookresourcesforotherPut(torrowId: kotlin.String, body: BookResourcesForOthersReq? = null): kotlin.Array<CaseParticipant> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/caseparticipation/bookresourcesforother".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<kotlin.Array<CaseParticipant>>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<CaseParticipant>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return kotlin.Array<CaseParticipant>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdCaseparticipationCancelcaseparticipationPut(torrowId: kotlin.String, body: CancelCaseParticipationReq? = null): kotlin.Array<CaseParticipant> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/caseparticipation/cancelcaseparticipation".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<kotlin.Array<CaseParticipant>>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<CaseParticipant>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param profileId  (optional)
     * @return CaseParticipant
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdCaseparticipationCancelmycaseparticipationPut(torrowId: kotlin.String, body: CancelMyCaseParticipationReq? = null, profileId: kotlin.String? = null): CaseParticipant {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("profileId" to listOf("$profileId"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/caseparticipation/cancelmycaseparticipation".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<CaseParticipant>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CaseParticipant
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return kotlin.Array<CaseParticipant>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdCaseparticipationCancelothercaseparticipationPut(torrowId: kotlin.String, body: CancelOtherCaseParticipationReq? = null): kotlin.Array<CaseParticipant> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/caseparticipation/cancelothercaseparticipation".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<kotlin.Array<CaseParticipant>>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<CaseParticipant>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return kotlin.Array<CaseParticipant>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdCaseparticipationCheckinPut(torrowId: kotlin.String, body: CheckInReq? = null): kotlin.Array<CaseParticipant> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/caseparticipation/checkin".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<kotlin.Array<CaseParticipant>>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<CaseParticipant>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param message  (optional)
     * @return CaseParticipant
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdCaseparticipationCheckinmyselfPut(torrowId: kotlin.String, body: CheckInProps? = null, message: kotlin.String? = null): CaseParticipant {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("message" to listOf("$message"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/caseparticipation/checkinmyself".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<CaseParticipant>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CaseParticipant
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return kotlin.Array<CaseParticipant>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdCaseparticipationCheckinotherPut(torrowId: kotlin.String, body: CheckInOtherReq? = null): kotlin.Array<CaseParticipant> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/caseparticipation/checkinother".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<kotlin.Array<CaseParticipant>>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<CaseParticipant>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param profileId  (optional)
     * @param userMessage  (optional)
     * @return CaseItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdCompletePost(torrowId: kotlin.String, profileId: kotlin.String? = null, userMessage: kotlin.String? = null): CaseItem {
        val localVariableQuery: MultiValueMap = mapOf("profileId" to listOf("$profileId"), "userMessage" to listOf("$userMessage"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/cases/{torrowId}/complete".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<CaseItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CaseItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param profileId  (optional)
     * @param userMessage  (optional)
     * @return CaseItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdDeclineworkPost(torrowId: kotlin.String, profileId: kotlin.String? = null, userMessage: kotlin.String? = null): CaseItem {
        val localVariableQuery: MultiValueMap = mapOf("profileId" to listOf("$profileId"), "userMessage" to listOf("$userMessage"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/cases/{torrowId}/declinework".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<CaseItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CaseItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param cascade  (optional)
     * @param withPinnedItems  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return DeleteResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdDelete(torrowId: kotlin.String, cascade: kotlin.Boolean? = null, withPinnedItems: kotlin.Boolean? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): DeleteResponse {
        val localVariableQuery: MultiValueMap = mapOf("cascade" to listOf("$cascade"), "withPinnedItems" to listOf("$withPinnedItems"), "versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/api/v1/cases/{torrowId}".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<DeleteResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as DeleteResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdFeedbacksOptionsPut(torrowId: kotlin.String, body: FeedbackOptions? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/feedbacks/options".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return GenerateSecurityTokenResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdGeneratesecuritytokenPost(torrowId: kotlin.String, body: GenerateSecurityTokenReq? = null): GenerateSecurityTokenResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/cases/{torrowId}/generatesecuritytoken".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<GenerateSecurityTokenResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GenerateSecurityTokenResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param profileId  (optional)
     * @param caseParticipantProfileId  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param includeDeleted  (optional, default to false)
     * @param includeChildTypes  (optional, default to false)
     * @param securityToken  (optional)
     * @return CaseItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdGet(torrowId: kotlin.String, profileId: kotlin.String? = null, caseParticipantProfileId: kotlin.String? = null, versionToCheck: kotlin.Int? = null, includeDeleted: kotlin.Boolean? = null, includeChildTypes: kotlin.Boolean? = null, securityToken: kotlin.String? = null): CaseItem {
        val localVariableQuery: MultiValueMap = mapOf("profileId" to listOf("$profileId"), "caseParticipantProfileId" to listOf("$caseParticipantProfileId"), "versionToCheck" to listOf("$versionToCheck"), "includeDeleted" to listOf("$includeDeleted"), "includeChildTypes" to listOf("$includeChildTypes"), "securityToken" to listOf("$securityToken"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/cases/{torrowId}".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<CaseItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CaseItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param itemType  (optional)
     * @param minParticipantType  (optional)
     * @param operationType  (optional)
     * @param recursionDepth  (optional, default to 0)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @return kotlin.Array<TorrowItem>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdGroupListGet(torrowId: kotlin.String, itemType: TorrowObjectType? = null, minParticipantType: ParticipantType? = null, operationType: OperationType? = null, recursionDepth: kotlin.Int? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null): kotlin.Array<TorrowItem> {
        val localVariableQuery: MultiValueMap = mapOf("itemType" to listOf("$itemType"), "minParticipantType" to listOf("$minParticipantType"), "operationType" to listOf("$operationType"), "recursionDepth" to listOf("$recursionDepth"), "take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/cases/{torrowId}/group/list".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<TorrowItem>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<TorrowItem>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return TorrowItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdGroupSetPut(torrowId: kotlin.String, body: SetGroupItemReq? = null): TorrowItem {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/group/set".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<TorrowItem>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return TorrowItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdGroupUnsetPut(torrowId: kotlin.String, body: UnsetGroupItemReq? = null): TorrowItem {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/group/unset".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<TorrowItem>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param parentId  (optional)
     * @param itemType  (optional)
     * @param minParticipantType  (optional)
     * @param operationType  (optional)
     * @param recursionDepth  (optional, default to 0)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @return kotlin.Array<GroupStatus>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdGroupsGet(torrowId: kotlin.String, parentId: kotlin.String? = null, itemType: TorrowObjectType? = null, minParticipantType: ParticipantType? = null, operationType: OperationType? = null, recursionDepth: kotlin.Int? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null): kotlin.Array<GroupStatus> {
        val localVariableQuery: MultiValueMap = mapOf("parentId" to listOf("$parentId"), "itemType" to listOf("$itemType"), "minParticipantType" to listOf("$minParticipantType"), "operationType" to listOf("$operationType"), "recursionDepth" to listOf("$recursionDepth"), "take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/cases/{torrowId}/groups".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<GroupStatus>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<GroupStatus>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return UpdateFileIdResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdImageIdPut(torrowId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): UpdateFileIdResp {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/image/id".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<UpdateFileIdResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UpdateFileIdResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @return FileInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdImageInfoGet(torrowId: kotlin.String): FileInfo {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/cases/{torrowId}/image/info".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<FileInfo>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param fileId  (optional)
     * @param fileName  (optional)
     * @param fileSize  (optional, default to 0)
     * @return PutUrlResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdImagePuturlGet(torrowId: kotlin.String, fileId: kotlin.String? = null, fileName: kotlin.String? = null, fileSize: kotlin.Long? = null): PutUrlResp {
        val localVariableQuery: MultiValueMap = mapOf("fileId" to listOf("$fileId"), "fileName" to listOf("$fileName"), "fileSize" to listOf("$fileSize"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/cases/{torrowId}/image/puturl".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<PutUrlResp>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PutUrlResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdIntegrationsPut(torrowId: kotlin.String, body: kotlin.Array<kotlin.String>? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/integrations".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdMasterinfoPut(torrowId: kotlin.String, body: UpdateMasterInfoReq? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/masterinfo".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @return GetParticipationCountResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdParticipantsAnonymousGet(torrowId: kotlin.String): GetParticipationCountResp {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/cases/{torrowId}/participants/anonymous".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<GetParticipationCountResp>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetParticipationCountResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param participantStateList  (optional)
     * @param participantTypeList  (optional)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @return kotlin.Array<ParticipantView>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdParticipantsGet(torrowId: kotlin.String, participantStateList: kotlin.Array<ParticipantState>? = null, participantTypeList: kotlin.Array<ParticipantType>? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null): kotlin.Array<ParticipantView> {
        val localVariableQuery: MultiValueMap = mapOf("participantStateList" to toMultiValue(participantStateList!!.toList(), "multi"), "participantTypeList" to toMultiValue(participantTypeList!!.toList(), "multi"), "take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/cases/{torrowId}/participants".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<ParticipantView>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ParticipantView>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param participantStateList  (optional)
     * @param participantTypeList  (optional)
     * @return GetParticipationCountResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdParticipantsNonanonymousGet(torrowId: kotlin.String, participantStateList: kotlin.Array<ParticipantState>? = null, participantTypeList: kotlin.Array<ParticipantType>? = null): GetParticipationCountResp {
        val localVariableQuery: MultiValueMap = mapOf("participantStateList" to toMultiValue(participantStateList!!.toList(), "multi"), "participantTypeList" to toMultiValue(participantTypeList!!.toList(), "multi"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/cases/{torrowId}/participants/nonanonymous".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<GetParticipationCountResp>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetParticipationCountResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param userMessage  (optional)
     * @return ParticipationResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdParticipationDeclineaccessPut(torrowId: kotlin.String, body: kotlin.Array<kotlin.String>? = null, userMessage: kotlin.String? = null): ParticipationResp {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("userMessage" to listOf("$userMessage"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/participation/declineaccess".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<ParticipationResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ParticipationResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return ParticipationResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdParticipationGrantaccessPut(torrowId: kotlin.String, body: kotlin.Array<kotlin.String>? = null): ParticipationResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/participation/grantaccess".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<ParticipationResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ParticipationResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param participantProfileId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdParticipationParticipantProfileIdTypePut(torrowId: kotlin.String, participantProfileId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/participation/{participantProfileId}/type".replace("{" + "torrowId" + "}", "$torrowId").replace("{" + "participantProfileId" + "}", "$participantProfileId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return Participation
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdParticipationRejectPut(torrowId: kotlin.String, body: kotlin.String? = null): Participation {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/participation/reject".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<Participation>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Participation
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param userMessage  (optional)
     * @return Participation
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdParticipationRejectofferPut(torrowId: kotlin.String, body: kotlin.String? = null, userMessage: kotlin.String? = null): Participation {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("userMessage" to listOf("$userMessage"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/participation/rejectoffer".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<Participation>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Participation
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param userMessage  (optional)
     * @return Participation
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdParticipationRequestaccessPut(torrowId: kotlin.String, body: kotlin.String? = null, userMessage: kotlin.String? = null): Participation {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("userMessage" to listOf("$userMessage"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/participation/requestaccess".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<Participation>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Participation
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return ParticipationResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdParticipationRevokeofferPut(torrowId: kotlin.String, body: kotlin.Array<kotlin.String>? = null): ParticipationResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/participation/revokeoffer".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<ParticipationResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ParticipationResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @return Participation
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdParticipationRevokerequestPut(torrowId: kotlin.String): Participation {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/participation/revokerequest".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<Participation>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Participation
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return ParticipationResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdParticipationSharePut(torrowId: kotlin.String, body: ShareItemReq? = null): ParticipationResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/participation/share".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<ParticipationResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ParticipationResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdParticipationShareitemlinkPost(torrowId: kotlin.String, body: GetShareItemSessionReq? = null): kotlin.String {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/cases/{torrowId}/participation/shareitemlink".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<kotlin.String>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return CaseItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdPatchPost(torrowId: kotlin.String, body: PatchCaseReq? = null): CaseItem {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/cases/{torrowId}/patch".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<CaseItem>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CaseItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param profileId  (optional)
     * @param userMessage  (optional)
     * @return CaseItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdPlanPost(torrowId: kotlin.String, profileId: kotlin.String? = null, userMessage: kotlin.String? = null): CaseItem {
        val localVariableQuery: MultiValueMap = mapOf("profileId" to listOf("$profileId"), "userMessage" to listOf("$userMessage"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/cases/{torrowId}/plan".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<CaseItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CaseItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdPublicityPut(torrowId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/publicity".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param profileId  (optional)
     * @param checkVersion  (optional, default to true)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return CaseItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdPut(torrowId: kotlin.String, body: CaseItem? = null, profileId: kotlin.String? = null, checkVersion: kotlin.Boolean? = null, isNeedAnnouncement: kotlin.Boolean? = null): CaseItem {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("profileId" to listOf("$profileId"), "checkVersion" to listOf("$checkVersion"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<CaseItem>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CaseItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param profileId  (optional)
     * @param userMessage  (optional)
     * @return CaseItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdRejectPost(torrowId: kotlin.String, profileId: kotlin.String? = null, userMessage: kotlin.String? = null): CaseItem {
        val localVariableQuery: MultiValueMap = mapOf("profileId" to listOf("$profileId"), "userMessage" to listOf("$userMessage"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/cases/{torrowId}/reject".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<CaseItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CaseItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param resourceGroupId  (optional)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param includeDeleted  (optional, default to false)
     * @return kotlin.Array<ResourceView>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdResourcesGet(torrowId: kotlin.String, resourceGroupId: kotlin.String? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, includeDeleted: kotlin.Boolean? = null): kotlin.Array<ResourceView> {
        val localVariableQuery: MultiValueMap = mapOf("resourceGroupId" to listOf("$resourceGroupId"), "take" to listOf("$take"), "skip" to listOf("$skip"), "includeDeleted" to listOf("$includeDeleted"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/cases/{torrowId}/resources".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<ResourceView>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ResourceView>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param profileId  (optional)
     * @param userMessage  (optional)
     * @return CaseItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdReturntoverificationPost(torrowId: kotlin.String, profileId: kotlin.String? = null, userMessage: kotlin.String? = null): CaseItem {
        val localVariableQuery: MultiValueMap = mapOf("profileId" to listOf("$profileId"), "userMessage" to listOf("$userMessage"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/cases/{torrowId}/returntoverification".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<CaseItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CaseItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return Participation
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdSavetomindmapPut(torrowId: kotlin.String, body: SaveItemToMindMapReq? = null): Participation {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/savetomindmap".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<Participation>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Participation
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdShorturlPost(torrowId: kotlin.String): kotlin.String {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/cases/{torrowId}/shorturl".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<kotlin.String>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdSolutiondataPut(torrowId: kotlin.String, body: SolutionData? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/solutiondata".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param itemType  (optional)
     * @param text  (optional)
     * @param minParticipantType  (optional)
     * @param operationType  (optional)
     * @param recursionDepth  (optional, default to 0)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @return kotlin.Array<kotlin.String>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdTagsGet(torrowId: kotlin.String, itemType: TorrowObjectType? = null, text: kotlin.String? = null, minParticipantType: ParticipantType? = null, operationType: OperationType? = null, recursionDepth: kotlin.Int? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null): kotlin.Array<kotlin.String> {
        val localVariableQuery: MultiValueMap = mapOf("itemType" to listOf("$itemType"), "text" to listOf("$text"), "minParticipantType" to listOf("$minParticipantType"), "operationType" to listOf("$operationType"), "recursionDepth" to listOf("$recursionDepth"), "take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/cases/{torrowId}/tags".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<kotlin.String>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.String>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdTagsPut(torrowId: kotlin.String, body: kotlin.Array<kotlin.String>? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/tags".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param profileId  (optional)
     * @param userMessage  (optional)
     * @return CaseItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdTakeinworkPost(torrowId: kotlin.String, profileId: kotlin.String? = null, userMessage: kotlin.String? = null): CaseItem {
        val localVariableQuery: MultiValueMap = mapOf("profileId" to listOf("$profileId"), "userMessage" to listOf("$userMessage"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/cases/{torrowId}/takeinwork".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<CaseItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CaseItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdTorrowaccountIdPut(torrowId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/torrowaccount/id".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param parentId  (optional)
     * @param parentTags  (optional)
     * @param parentAlias  (optional)
     * @param tags  (optional)
     * @param alias  (optional)
     * @param versionToCheck  (optional)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return IncludeExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesTorrowIdUpdategroupsPut(torrowId: kotlin.String, body: kotlin.Array<UpdateItemGroupsReq>? = null, parentId: kotlin.String? = null, parentTags: kotlin.Array<kotlin.String>? = null, parentAlias: kotlin.String? = null, tags: kotlin.Array<kotlin.String>? = null, alias: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): IncludeExcludeResp {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("parentId" to listOf("$parentId"), "parentTags" to toMultiValue(parentTags!!.toList(), "multi"), "parentAlias" to listOf("$parentAlias"), "tags" to toMultiValue(tags!!.toList(), "multi"), "alias" to listOf("$alias"), "versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/cases/{torrowId}/updategroups".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<IncludeExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as IncludeExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param uniqueName  
     * @param profileId  (optional)
     * @return CaseItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CasesUniquenameUniqueNameGet(uniqueName: kotlin.String, profileId: kotlin.String? = null): CaseItem {
        val localVariableQuery: MultiValueMap = mapOf("profileId" to listOf("$profileId"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/cases/uniquename/{uniqueName}".replace("{" + "uniqueName" + "}", "$uniqueName"), query = localVariableQuery
        )
        val response = request<CaseItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CaseItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
