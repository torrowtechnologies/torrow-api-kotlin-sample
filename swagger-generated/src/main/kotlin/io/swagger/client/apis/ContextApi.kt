/**
 * Torrow API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import net.torrow.api.models.ContextItem
import net.torrow.api.models.DeleteResponse
import net.torrow.api.models.ExcludeFromGroupsReq
import net.torrow.api.models.ExcludeReq
import net.torrow.api.models.ExcludeResp
import net.torrow.api.models.FeedbackOptions
import net.torrow.api.models.FileInfo
import net.torrow.api.models.GetParticipationCountResp
import net.torrow.api.models.GetShareItemSessionReq
import net.torrow.api.models.GroupStatus
import net.torrow.api.models.IncludeExcludeResp
import net.torrow.api.models.IncludeForUserReq
import net.torrow.api.models.IncludeToGroupsReq
import net.torrow.api.models.IncludeToParentReq
import net.torrow.api.models.ItemViewSortCondition
import net.torrow.api.models.NotificationWay
import net.torrow.api.models.ObjectInfo
import net.torrow.api.models.OperationType
import net.torrow.api.models.ParticipantState
import net.torrow.api.models.ParticipantType
import net.torrow.api.models.ParticipantView
import net.torrow.api.models.Participation
import net.torrow.api.models.ParticipationResp
import net.torrow.api.models.PersonalReminder
import net.torrow.api.models.PersonalSolutionData
import net.torrow.api.models.PutUrlResp
import net.torrow.api.models.SaveItemToMindMapReq
import net.torrow.api.models.SendLinkOfItemReq
import net.torrow.api.models.SendLinkOfItemResp
import net.torrow.api.models.SetGroupItemReq
import net.torrow.api.models.ShareItemReq
import net.torrow.api.models.SolutionData
import net.torrow.api.models.TorrowItem
import net.torrow.api.models.TorrowObject
import net.torrow.api.models.TorrowObjectType
import net.torrow.api.models.UnsetGroupItemReq
import net.torrow.api.models.UpdateFileIdResp
import net.torrow.api.models.UpdateItemGroupsReq
import net.torrow.api.models.UpdateMasterInfoReq
import net.torrow.api.models.UpdatePersonalListOrderReq
import net.torrow.api.models.UpdatePersonalListOrderResp

import io.swagger.client.infrastructure.*

class ContextApi(basePath: kotlin.String = "/") : ApiClient(basePath) {

    /**
     * 
     * 
     * @param body  (optional)
     * @return ExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsExcludeFromgroupsPut(body: ExcludeFromGroupsReq? = null): ExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/exclude/fromgroups"
        )
        val response = request<ExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @return IncludeExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsIncludeTogroupsPut(body: IncludeToGroupsReq? = null): IncludeExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/include/togroups"
        )
        val response = request<IncludeExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as IncludeExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsItemIdAliasPut(itemId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{itemId}/alias".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param reasonId  (optional)
     * @param reasonContext  (optional)
     * @param language  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsItemIdBlockPost(itemId: kotlin.String, reasonId: kotlin.Int? = null, reasonContext: kotlin.String? = null, language: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowItem {
        val localVariableQuery: MultiValueMap = mapOf("reasonId" to listOf("$reasonId"), "reasonContext" to listOf("$reasonContext"), "language" to listOf("$language"), "versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/contexts/{itemId}/block".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<TorrowItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsItemIdLastusagetimePut(itemId: kotlin.String, body: java.time.LocalDateTime? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{itemId}/lastusagetime".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsItemIdNotificationwaylistPut(itemId: kotlin.String, body: kotlin.Array<NotificationWay>? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{itemId}/notificationwaylist".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsItemIdOfflinablePut(itemId: kotlin.String, body: kotlin.Boolean? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{itemId}/offlinable".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsItemIdParticipationProfilePut(itemId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{itemId}/participation/profile".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsItemIdPersonalsolutiondataPut(itemId: kotlin.String, body: PersonalSolutionData? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{itemId}/personalsolutiondata".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsItemIdRemindersPut(itemId: kotlin.String, body: kotlin.Array<PersonalReminder>? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{itemId}/reminders".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @return SendLinkOfItemResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsItemIdSendlinkPut(itemId: kotlin.String, body: SendLinkOfItemReq? = null): SendLinkOfItemResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{itemId}/sendlink".replace("{" + "itemId" + "}", "$itemId")
        )
        val response = request<SendLinkOfItemResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as SendLinkOfItemResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsItemIdUnblockPost(itemId: kotlin.String, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowItem {
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/contexts/{itemId}/unblock".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<TorrowItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsItemIdUniquenamePut(itemId: kotlin.String, body: kotlin.String? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{itemId}/uniquename".replace("{" + "itemId" + "}", "$itemId")
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param parentId  
     * @param body  (optional)
     * @return ExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsParentIdExcludeFromuserPut(parentId: kotlin.String, body: ExcludeReq? = null): ExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{parentId}/exclude/fromuser".replace("{" + "parentId" + "}", "$parentId")
        )
        val response = request<ExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param parentId  
     * @param body  (optional)
     * @return ExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsParentIdExcludeItemsPut(parentId: kotlin.String, body: ExcludeReq? = null): ExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{parentId}/exclude/items".replace("{" + "parentId" + "}", "$parentId")
        )
        val response = request<ExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param parentId  
     * @param body  (optional)
     * @return IncludeExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsParentIdIncludeForuserPut(parentId: kotlin.String, body: IncludeForUserReq? = null): IncludeExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{parentId}/include/foruser".replace("{" + "parentId" + "}", "$parentId")
        )
        val response = request<IncludeExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as IncludeExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param parentId  
     * @param body  (optional)
     * @return IncludeExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsParentIdIncludeItemsPut(parentId: kotlin.String, body: IncludeToParentReq? = null): IncludeExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{parentId}/include/items".replace("{" + "parentId" + "}", "$parentId")
        )
        val response = request<IncludeExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as IncludeExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @param profileId  (optional)
     * @param onlyWithEmptyProfile  (optional)
     * @param participantStateList  (optional)
     * @param participantTypeList  (optional)
     * @return kotlin.Array<ContextItem>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsPersonallistGet(take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null, profileId: kotlin.String? = null, onlyWithEmptyProfile: kotlin.Boolean? = null, participantStateList: kotlin.Array<ParticipantState>? = null, participantTypeList: kotlin.Array<ParticipantType>? = null): kotlin.Array<ContextItem> {
        val localVariableQuery: MultiValueMap = mapOf("take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"), "profileId" to listOf("$profileId"), "onlyWithEmptyProfile" to listOf("$onlyWithEmptyProfile"), "participantStateList" to toMultiValue(participantStateList!!.toList(), "multi"), "participantTypeList" to toMultiValue(participantTypeList!!.toList(), "multi"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/contexts/personallist", query = localVariableQuery
        )
        val response = request<kotlin.Array<ContextItem>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ContextItem>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @return void
     */
    fun apiV1ContextsPersonallistItemIdDelete(itemId: kotlin.String): Unit {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/api/v1/contexts/personallist/{itemId}".replace("{" + "itemId" + "}", "$itemId")
        )
        val response = request<Any?>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @return UpdatePersonalListOrderResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsPersonallistUpdateorderPost(body: UpdatePersonalListOrderReq? = null): UpdatePersonalListOrderResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/contexts/personallist/updateorder"
        )
        val response = request<UpdatePersonalListOrderResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UpdatePersonalListOrderResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @param profileId  (optional)
     * @return ContextItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsPost(body: ContextItem? = null, profileId: kotlin.String? = null): ContextItem {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("profileId" to listOf("$profileId"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/contexts", query = localVariableQuery
        )
        val response = request<ContextItem>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ContextItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param cascade  (optional)
     * @param withPinnedItems  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return DeleteResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdDelete(torrowId: kotlin.String, cascade: kotlin.Boolean? = null, withPinnedItems: kotlin.Boolean? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): DeleteResponse {
        val localVariableQuery: MultiValueMap = mapOf("cascade" to listOf("$cascade"), "withPinnedItems" to listOf("$withPinnedItems"), "versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/api/v1/contexts/{torrowId}".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<DeleteResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as DeleteResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdFeedbacksOptionsPut(torrowId: kotlin.String, body: FeedbackOptions? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/feedbacks/options".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param versionToCheck  (optional, default to 0)
     * @param includeDeleted  (optional, default to false)
     * @param includeChildTypes  (optional, default to false)
     * @return ContextItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdGet(torrowId: kotlin.String, versionToCheck: kotlin.Int? = null, includeDeleted: kotlin.Boolean? = null, includeChildTypes: kotlin.Boolean? = null): ContextItem {
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "includeDeleted" to listOf("$includeDeleted"), "includeChildTypes" to listOf("$includeChildTypes"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/contexts/{torrowId}".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<ContextItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ContextItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param itemType  (optional)
     * @param minParticipantType  (optional)
     * @param operationType  (optional)
     * @param recursionDepth  (optional, default to 0)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @return kotlin.Array<TorrowItem>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdGroupListGet(torrowId: kotlin.String, itemType: TorrowObjectType? = null, minParticipantType: ParticipantType? = null, operationType: OperationType? = null, recursionDepth: kotlin.Int? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null): kotlin.Array<TorrowItem> {
        val localVariableQuery: MultiValueMap = mapOf("itemType" to listOf("$itemType"), "minParticipantType" to listOf("$minParticipantType"), "operationType" to listOf("$operationType"), "recursionDepth" to listOf("$recursionDepth"), "take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/contexts/{torrowId}/group/list".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<TorrowItem>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<TorrowItem>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return TorrowItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdGroupSetPut(torrowId: kotlin.String, body: SetGroupItemReq? = null): TorrowItem {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/group/set".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<TorrowItem>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return TorrowItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdGroupUnsetPut(torrowId: kotlin.String, body: UnsetGroupItemReq? = null): TorrowItem {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/group/unset".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<TorrowItem>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param parentId  (optional)
     * @param itemType  (optional)
     * @param minParticipantType  (optional)
     * @param operationType  (optional)
     * @param recursionDepth  (optional, default to 0)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @return kotlin.Array<GroupStatus>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdGroupsGet(torrowId: kotlin.String, parentId: kotlin.String? = null, itemType: TorrowObjectType? = null, minParticipantType: ParticipantType? = null, operationType: OperationType? = null, recursionDepth: kotlin.Int? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null): kotlin.Array<GroupStatus> {
        val localVariableQuery: MultiValueMap = mapOf("parentId" to listOf("$parentId"), "itemType" to listOf("$itemType"), "minParticipantType" to listOf("$minParticipantType"), "operationType" to listOf("$operationType"), "recursionDepth" to listOf("$recursionDepth"), "take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/contexts/{torrowId}/groups".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<GroupStatus>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<GroupStatus>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return UpdateFileIdResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdImageIdPut(torrowId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): UpdateFileIdResp {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/image/id".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<UpdateFileIdResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UpdateFileIdResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @return FileInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdImageInfoGet(torrowId: kotlin.String): FileInfo {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/contexts/{torrowId}/image/info".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<FileInfo>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param fileId  (optional)
     * @param fileName  (optional)
     * @param fileSize  (optional, default to 0)
     * @return PutUrlResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdImagePuturlGet(torrowId: kotlin.String, fileId: kotlin.String? = null, fileName: kotlin.String? = null, fileSize: kotlin.Long? = null): PutUrlResp {
        val localVariableQuery: MultiValueMap = mapOf("fileId" to listOf("$fileId"), "fileName" to listOf("$fileName"), "fileSize" to listOf("$fileSize"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/contexts/{torrowId}/image/puturl".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<PutUrlResp>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PutUrlResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdIntegrationsPut(torrowId: kotlin.String, body: kotlin.Array<kotlin.String>? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/integrations".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdMasterinfoPut(torrowId: kotlin.String, body: UpdateMasterInfoReq? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/masterinfo".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @return GetParticipationCountResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdParticipantsAnonymousGet(torrowId: kotlin.String): GetParticipationCountResp {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/contexts/{torrowId}/participants/anonymous".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<GetParticipationCountResp>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetParticipationCountResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param participantStateList  (optional)
     * @param participantTypeList  (optional)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @return kotlin.Array<ParticipantView>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdParticipantsGet(torrowId: kotlin.String, participantStateList: kotlin.Array<ParticipantState>? = null, participantTypeList: kotlin.Array<ParticipantType>? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null): kotlin.Array<ParticipantView> {
        val localVariableQuery: MultiValueMap = mapOf("participantStateList" to toMultiValue(participantStateList!!.toList(), "multi"), "participantTypeList" to toMultiValue(participantTypeList!!.toList(), "multi"), "take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/contexts/{torrowId}/participants".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<ParticipantView>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ParticipantView>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param participantStateList  (optional)
     * @param participantTypeList  (optional)
     * @return GetParticipationCountResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdParticipantsNonanonymousGet(torrowId: kotlin.String, participantStateList: kotlin.Array<ParticipantState>? = null, participantTypeList: kotlin.Array<ParticipantType>? = null): GetParticipationCountResp {
        val localVariableQuery: MultiValueMap = mapOf("participantStateList" to toMultiValue(participantStateList!!.toList(), "multi"), "participantTypeList" to toMultiValue(participantTypeList!!.toList(), "multi"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/contexts/{torrowId}/participants/nonanonymous".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<GetParticipationCountResp>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetParticipationCountResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param userMessage  (optional)
     * @return ParticipationResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdParticipationDeclineaccessPut(torrowId: kotlin.String, body: kotlin.Array<kotlin.String>? = null, userMessage: kotlin.String? = null): ParticipationResp {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("userMessage" to listOf("$userMessage"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/participation/declineaccess".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<ParticipationResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ParticipationResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return ParticipationResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdParticipationGrantaccessPut(torrowId: kotlin.String, body: kotlin.Array<kotlin.String>? = null): ParticipationResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/participation/grantaccess".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<ParticipationResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ParticipationResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param participantProfileId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdParticipationParticipantProfileIdTypePut(torrowId: kotlin.String, participantProfileId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/participation/{participantProfileId}/type".replace("{" + "torrowId" + "}", "$torrowId").replace("{" + "participantProfileId" + "}", "$participantProfileId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return Participation
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdParticipationRejectPut(torrowId: kotlin.String, body: kotlin.String? = null): Participation {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/participation/reject".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<Participation>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Participation
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param userMessage  (optional)
     * @return Participation
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdParticipationRejectofferPut(torrowId: kotlin.String, body: kotlin.String? = null, userMessage: kotlin.String? = null): Participation {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("userMessage" to listOf("$userMessage"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/participation/rejectoffer".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<Participation>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Participation
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param userMessage  (optional)
     * @return Participation
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdParticipationRequestaccessPut(torrowId: kotlin.String, body: kotlin.String? = null, userMessage: kotlin.String? = null): Participation {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("userMessage" to listOf("$userMessage"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/participation/requestaccess".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<Participation>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Participation
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return ParticipationResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdParticipationRevokeofferPut(torrowId: kotlin.String, body: kotlin.Array<kotlin.String>? = null): ParticipationResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/participation/revokeoffer".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<ParticipationResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ParticipationResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @return Participation
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdParticipationRevokerequestPut(torrowId: kotlin.String): Participation {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/participation/revokerequest".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<Participation>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Participation
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return ParticipationResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdParticipationSharePut(torrowId: kotlin.String, body: ShareItemReq? = null): ParticipationResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/participation/share".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<ParticipationResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ParticipationResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdParticipationShareitemlinkPost(torrowId: kotlin.String, body: GetShareItemSessionReq? = null): kotlin.String {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/contexts/{torrowId}/participation/shareitemlink".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<kotlin.String>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdPublicityPut(torrowId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/publicity".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param checkVersion  (optional, default to true)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ContextItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdPut(torrowId: kotlin.String, body: ContextItem? = null, checkVersion: kotlin.Boolean? = null, isNeedAnnouncement: kotlin.Boolean? = null): ContextItem {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("checkVersion" to listOf("$checkVersion"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<ContextItem>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ContextItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return Participation
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdSavetomindmapPut(torrowId: kotlin.String, body: SaveItemToMindMapReq? = null): Participation {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/savetomindmap".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<Participation>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Participation
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdShorturlPost(torrowId: kotlin.String): kotlin.String {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/contexts/{torrowId}/shorturl".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<kotlin.String>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdSolutiondataPut(torrowId: kotlin.String, body: SolutionData? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/solutiondata".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param itemType  (optional)
     * @param text  (optional)
     * @param minParticipantType  (optional)
     * @param operationType  (optional)
     * @param recursionDepth  (optional, default to 0)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @return kotlin.Array<kotlin.String>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdTagsGet(torrowId: kotlin.String, itemType: TorrowObjectType? = null, text: kotlin.String? = null, minParticipantType: ParticipantType? = null, operationType: OperationType? = null, recursionDepth: kotlin.Int? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null): kotlin.Array<kotlin.String> {
        val localVariableQuery: MultiValueMap = mapOf("itemType" to listOf("$itemType"), "text" to listOf("$text"), "minParticipantType" to listOf("$minParticipantType"), "operationType" to listOf("$operationType"), "recursionDepth" to listOf("$recursionDepth"), "take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/contexts/{torrowId}/tags".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<kotlin.String>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.String>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdTagsPut(torrowId: kotlin.String, body: kotlin.Array<kotlin.String>? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/tags".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdTorrowaccountIdPut(torrowId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/torrowaccount/id".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param parentId  (optional)
     * @param parentTags  (optional)
     * @param parentAlias  (optional)
     * @param tags  (optional)
     * @param alias  (optional)
     * @param versionToCheck  (optional)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return IncludeExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsTorrowIdUpdategroupsPut(torrowId: kotlin.String, body: kotlin.Array<UpdateItemGroupsReq>? = null, parentId: kotlin.String? = null, parentTags: kotlin.Array<kotlin.String>? = null, parentAlias: kotlin.String? = null, tags: kotlin.Array<kotlin.String>? = null, alias: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): IncludeExcludeResp {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("parentId" to listOf("$parentId"), "parentTags" to toMultiValue(parentTags!!.toList(), "multi"), "parentAlias" to listOf("$parentAlias"), "tags" to toMultiValue(tags!!.toList(), "multi"), "alias" to listOf("$alias"), "versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/contexts/{torrowId}/updategroups".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<IncludeExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as IncludeExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param uniquename  
     * @return ContextItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1ContextsUniquenameUniquenameGet(uniquename: kotlin.String): ContextItem {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/contexts/uniquename/{uniquename}".replace("{" + "uniquename" + "}", "$uniquename")
        )
        val response = request<ContextItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ContextItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
