/**
 * Torrow API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import net.torrow.api.models.CalendarItem
import net.torrow.api.models.DeleteResponse
import net.torrow.api.models.ExcludeFromGroupsReq
import net.torrow.api.models.ExcludeReq
import net.torrow.api.models.ExcludeResp
import net.torrow.api.models.FeedbackOptions
import net.torrow.api.models.FileInfo
import net.torrow.api.models.GetParticipationCountResp
import net.torrow.api.models.GetShareItemSessionReq
import net.torrow.api.models.GroupStatus
import net.torrow.api.models.IncludeExcludeResp
import net.torrow.api.models.IncludeForUserReq
import net.torrow.api.models.IncludeToGroupsReq
import net.torrow.api.models.IncludeToParentReq
import net.torrow.api.models.ItemViewSortCondition
import net.torrow.api.models.NotificationWay
import net.torrow.api.models.ObjectInfo
import net.torrow.api.models.OperationType
import net.torrow.api.models.ParticipantState
import net.torrow.api.models.ParticipantType
import net.torrow.api.models.ParticipantView
import net.torrow.api.models.Participation
import net.torrow.api.models.ParticipationResp
import net.torrow.api.models.PersonalReminder
import net.torrow.api.models.PersonalSolutionData
import net.torrow.api.models.PutUrlResp
import net.torrow.api.models.SaveItemToMindMapReq
import net.torrow.api.models.SendLinkOfItemReq
import net.torrow.api.models.SendLinkOfItemResp
import net.torrow.api.models.SetGroupItemReq
import net.torrow.api.models.ShareItemReq
import net.torrow.api.models.SolutionData
import net.torrow.api.models.TimetableCase
import net.torrow.api.models.TimetableDetailsVisibility
import net.torrow.api.models.TimetableFilter
import net.torrow.api.models.TorrowItem
import net.torrow.api.models.TorrowObject
import net.torrow.api.models.TorrowObjectType
import net.torrow.api.models.UnsetGroupItemReq
import net.torrow.api.models.UpdateFileIdResp
import net.torrow.api.models.UpdateItemGroupsReq
import net.torrow.api.models.UpdateMasterInfoReq
import net.torrow.api.models.UpdatePersonalListOrderReq
import net.torrow.api.models.UpdatePersonalListOrderResp

import io.swagger.client.infrastructure.*

class CalendarApi(basePath: kotlin.String = "/") : ApiClient(basePath) {

    /**
     * 
     * 
     * @param calendarId  
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsCalendarIdExcludecasePut(calendarId: kotlin.String, body: kotlin.Array<kotlin.String>? = null): kotlin.String {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{calendarId}/excludecase".replace("{" + "calendarId" + "}", "$calendarId")
        )
        val response = request<kotlin.String>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param calendarId  
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsCalendarIdExcludecasefromcustomcalendarPut(calendarId: kotlin.String, body: kotlin.Array<kotlin.String>? = null): kotlin.String {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{calendarId}/excludecasefromcustomcalendar".replace("{" + "calendarId" + "}", "$calendarId")
        )
        val response = request<kotlin.String>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param calendarId  
     * @param body  (optional)
     * @param profileId  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsCalendarIdIncludecasePut(calendarId: kotlin.String, body: kotlin.Array<kotlin.String>? = null, profileId: kotlin.String? = null): kotlin.String {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("profileId" to listOf("$profileId"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{calendarId}/includecase".replace("{" + "calendarId" + "}", "$calendarId"), query = localVariableQuery
        )
        val response = request<kotlin.String>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param calendarId  
     * @param body  (optional)
     * @param profileId  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsCalendarIdIncludecasetocustomcalendarPut(calendarId: kotlin.String, body: kotlin.Array<kotlin.String>? = null, profileId: kotlin.String? = null): kotlin.String {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("profileId" to listOf("$profileId"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{calendarId}/includecasetocustomcalendar".replace("{" + "calendarId" + "}", "$calendarId"), query = localVariableQuery
        )
        val response = request<kotlin.String>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @return ExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsExcludeFromgroupsPut(body: ExcludeFromGroupsReq? = null): ExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/exclude/fromgroups"
        )
        val response = request<ExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @return IncludeExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsIncludeTogroupsPut(body: IncludeToGroupsReq? = null): IncludeExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/include/togroups"
        )
        val response = request<IncludeExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as IncludeExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsItemIdAliasPut(itemId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{itemId}/alias".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param reasonId  (optional)
     * @param reasonCalendar  (optional)
     * @param language  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsItemIdBlockPost(itemId: kotlin.String, reasonId: kotlin.Int? = null, reasonCalendar: kotlin.String? = null, language: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowItem {
        val localVariableQuery: MultiValueMap = mapOf("reasonId" to listOf("$reasonId"), "reasonCalendar" to listOf("$reasonCalendar"), "language" to listOf("$language"), "versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/calendars/{itemId}/block".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<TorrowItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsItemIdLastusagetimePut(itemId: kotlin.String, body: java.time.LocalDateTime? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{itemId}/lastusagetime".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsItemIdNotificationwaylistPut(itemId: kotlin.String, body: kotlin.Array<NotificationWay>? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{itemId}/notificationwaylist".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsItemIdOfflinablePut(itemId: kotlin.String, body: kotlin.Boolean? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{itemId}/offlinable".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsItemIdParticipationProfilePut(itemId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{itemId}/participation/profile".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsItemIdPersonalsolutiondataPut(itemId: kotlin.String, body: PersonalSolutionData? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{itemId}/personalsolutiondata".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsItemIdRemindersPut(itemId: kotlin.String, body: kotlin.Array<PersonalReminder>? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{itemId}/reminders".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @return SendLinkOfItemResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsItemIdSendlinkPut(itemId: kotlin.String, body: SendLinkOfItemReq? = null): SendLinkOfItemResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{itemId}/sendlink".replace("{" + "itemId" + "}", "$itemId")
        )
        val response = request<SendLinkOfItemResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as SendLinkOfItemResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsItemIdUnblockPost(itemId: kotlin.String, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowItem {
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/calendars/{itemId}/unblock".replace("{" + "itemId" + "}", "$itemId"), query = localVariableQuery
        )
        val response = request<TorrowItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @param body  (optional)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsItemIdUniquenamePut(itemId: kotlin.String, body: kotlin.String? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{itemId}/uniquename".replace("{" + "itemId" + "}", "$itemId")
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param parentId  
     * @param body  (optional)
     * @return ExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsParentIdExcludeFromuserPut(parentId: kotlin.String, body: ExcludeReq? = null): ExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{parentId}/exclude/fromuser".replace("{" + "parentId" + "}", "$parentId")
        )
        val response = request<ExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param parentId  
     * @param body  (optional)
     * @return ExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsParentIdExcludeItemsPut(parentId: kotlin.String, body: ExcludeReq? = null): ExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{parentId}/exclude/items".replace("{" + "parentId" + "}", "$parentId")
        )
        val response = request<ExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param parentId  
     * @param body  (optional)
     * @return IncludeExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsParentIdIncludeForuserPut(parentId: kotlin.String, body: IncludeForUserReq? = null): IncludeExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{parentId}/include/foruser".replace("{" + "parentId" + "}", "$parentId")
        )
        val response = request<IncludeExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as IncludeExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param parentId  
     * @param body  (optional)
     * @return IncludeExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsParentIdIncludeItemsPut(parentId: kotlin.String, body: IncludeToParentReq? = null): IncludeExcludeResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{parentId}/include/items".replace("{" + "parentId" + "}", "$parentId")
        )
        val response = request<IncludeExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as IncludeExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @param profileId  (optional)
     * @param onlyWithEmptyProfile  (optional)
     * @param participantStateList  (optional)
     * @param participantTypeList  (optional)
     * @return kotlin.Array<CalendarItem>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsPersonallistGet(take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null, profileId: kotlin.String? = null, onlyWithEmptyProfile: kotlin.Boolean? = null, participantStateList: kotlin.Array<ParticipantState>? = null, participantTypeList: kotlin.Array<ParticipantType>? = null): kotlin.Array<CalendarItem> {
        val localVariableQuery: MultiValueMap = mapOf("take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"), "profileId" to listOf("$profileId"), "onlyWithEmptyProfile" to listOf("$onlyWithEmptyProfile"), "participantStateList" to toMultiValue(participantStateList!!.toList(), "multi"), "participantTypeList" to toMultiValue(participantTypeList!!.toList(), "multi"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/calendars/personallist", query = localVariableQuery
        )
        val response = request<kotlin.Array<CalendarItem>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<CalendarItem>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param itemId  
     * @return void
     */
    fun apiV1CalendarsPersonallistItemIdDelete(itemId: kotlin.String): Unit {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/api/v1/calendars/personallist/{itemId}".replace("{" + "itemId" + "}", "$itemId")
        )
        val response = request<Any?>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @return UpdatePersonalListOrderResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsPersonallistUpdateorderPost(body: UpdatePersonalListOrderReq? = null): UpdatePersonalListOrderResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/calendars/personallist/updateorder"
        )
        val response = request<UpdatePersonalListOrderResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UpdatePersonalListOrderResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param body  (optional)
     * @param parentId  (optional)
     * @param profileId  (optional)
     * @return CalendarItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsPost(body: CalendarItem? = null, parentId: kotlin.String? = null, profileId: kotlin.String? = null): CalendarItem {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("parentId" to listOf("$parentId"), "profileId" to listOf("$profileId"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/calendars", query = localVariableQuery
        )
        val response = request<CalendarItem>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CalendarItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param cascade  (optional)
     * @param withPinnedItems  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return DeleteResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdDelete(torrowId: kotlin.String, cascade: kotlin.Boolean? = null, withPinnedItems: kotlin.Boolean? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): DeleteResponse {
        val localVariableQuery: MultiValueMap = mapOf("cascade" to listOf("$cascade"), "withPinnedItems" to listOf("$withPinnedItems"), "versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/api/v1/calendars/{torrowId}".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<DeleteResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as DeleteResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdFeedbacksOptionsPut(torrowId: kotlin.String, body: FeedbackOptions? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/feedbacks/options".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param versionToCheck  (optional, default to 0)
     * @param includeDeleted  (optional, default to false)
     * @param includeChildItems  (optional, default to false)
     * @return CalendarItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdGet(torrowId: kotlin.String, versionToCheck: kotlin.Int? = null, includeDeleted: kotlin.Boolean? = null, includeChildItems: kotlin.Boolean? = null): CalendarItem {
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "includeDeleted" to listOf("$includeDeleted"), "includeChildItems" to listOf("$includeChildItems"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/calendars/{torrowId}".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<CalendarItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CalendarItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param itemType  (optional)
     * @param minParticipantType  (optional)
     * @param operationType  (optional)
     * @param recursionDepth  (optional, default to 0)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @return kotlin.Array<TorrowItem>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdGroupListGet(torrowId: kotlin.String, itemType: TorrowObjectType? = null, minParticipantType: ParticipantType? = null, operationType: OperationType? = null, recursionDepth: kotlin.Int? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null): kotlin.Array<TorrowItem> {
        val localVariableQuery: MultiValueMap = mapOf("itemType" to listOf("$itemType"), "minParticipantType" to listOf("$minParticipantType"), "operationType" to listOf("$operationType"), "recursionDepth" to listOf("$recursionDepth"), "take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/calendars/{torrowId}/group/list".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<TorrowItem>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<TorrowItem>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return TorrowItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdGroupSetPut(torrowId: kotlin.String, body: SetGroupItemReq? = null): TorrowItem {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/group/set".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<TorrowItem>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return TorrowItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdGroupUnsetPut(torrowId: kotlin.String, body: UnsetGroupItemReq? = null): TorrowItem {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/group/unset".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<TorrowItem>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param parentId  (optional)
     * @param itemType  (optional)
     * @param minParticipantType  (optional)
     * @param operationType  (optional)
     * @param recursionDepth  (optional, default to 0)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @return kotlin.Array<GroupStatus>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdGroupsGet(torrowId: kotlin.String, parentId: kotlin.String? = null, itemType: TorrowObjectType? = null, minParticipantType: ParticipantType? = null, operationType: OperationType? = null, recursionDepth: kotlin.Int? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null): kotlin.Array<GroupStatus> {
        val localVariableQuery: MultiValueMap = mapOf("parentId" to listOf("$parentId"), "itemType" to listOf("$itemType"), "minParticipantType" to listOf("$minParticipantType"), "operationType" to listOf("$operationType"), "recursionDepth" to listOf("$recursionDepth"), "take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/calendars/{torrowId}/groups".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<GroupStatus>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<GroupStatus>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return UpdateFileIdResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdImageIdPut(torrowId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): UpdateFileIdResp {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/image/id".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<UpdateFileIdResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UpdateFileIdResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @return FileInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdImageInfoGet(torrowId: kotlin.String): FileInfo {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/calendars/{torrowId}/image/info".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<FileInfo>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param fileId  (optional)
     * @param fileName  (optional)
     * @param fileSize  (optional, default to 0)
     * @return PutUrlResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdImagePuturlGet(torrowId: kotlin.String, fileId: kotlin.String? = null, fileName: kotlin.String? = null, fileSize: kotlin.Long? = null): PutUrlResp {
        val localVariableQuery: MultiValueMap = mapOf("fileId" to listOf("$fileId"), "fileName" to listOf("$fileName"), "fileSize" to listOf("$fileSize"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/calendars/{torrowId}/image/puturl".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<PutUrlResp>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PutUrlResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdIntegrationsPut(torrowId: kotlin.String, body: kotlin.Array<kotlin.String>? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/integrations".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdMasterinfoPut(torrowId: kotlin.String, body: UpdateMasterInfoReq? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/masterinfo".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @return GetParticipationCountResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdParticipantsAnonymousGet(torrowId: kotlin.String): GetParticipationCountResp {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/calendars/{torrowId}/participants/anonymous".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<GetParticipationCountResp>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetParticipationCountResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param participantStateList  (optional)
     * @param participantTypeList  (optional)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @return kotlin.Array<ParticipantView>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdParticipantsGet(torrowId: kotlin.String, participantStateList: kotlin.Array<ParticipantState>? = null, participantTypeList: kotlin.Array<ParticipantType>? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null): kotlin.Array<ParticipantView> {
        val localVariableQuery: MultiValueMap = mapOf("participantStateList" to toMultiValue(participantStateList!!.toList(), "multi"), "participantTypeList" to toMultiValue(participantTypeList!!.toList(), "multi"), "take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/calendars/{torrowId}/participants".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<ParticipantView>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ParticipantView>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param participantStateList  (optional)
     * @param participantTypeList  (optional)
     * @return GetParticipationCountResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdParticipantsNonanonymousGet(torrowId: kotlin.String, participantStateList: kotlin.Array<ParticipantState>? = null, participantTypeList: kotlin.Array<ParticipantType>? = null): GetParticipationCountResp {
        val localVariableQuery: MultiValueMap = mapOf("participantStateList" to toMultiValue(participantStateList!!.toList(), "multi"), "participantTypeList" to toMultiValue(participantTypeList!!.toList(), "multi"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/calendars/{torrowId}/participants/nonanonymous".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<GetParticipationCountResp>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetParticipationCountResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param userMessage  (optional)
     * @return ParticipationResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdParticipationDeclineaccessPut(torrowId: kotlin.String, body: kotlin.Array<kotlin.String>? = null, userMessage: kotlin.String? = null): ParticipationResp {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("userMessage" to listOf("$userMessage"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/participation/declineaccess".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<ParticipationResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ParticipationResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return ParticipationResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdParticipationGrantaccessPut(torrowId: kotlin.String, body: kotlin.Array<kotlin.String>? = null): ParticipationResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/participation/grantaccess".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<ParticipationResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ParticipationResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param participantProfileId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return ObjectInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdParticipationParticipantProfileIdTypePut(torrowId: kotlin.String, participantProfileId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): ObjectInfo {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/participation/{participantProfileId}/type".replace("{" + "torrowId" + "}", "$torrowId").replace("{" + "participantProfileId" + "}", "$participantProfileId"), query = localVariableQuery
        )
        val response = request<ObjectInfo>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ObjectInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return Participation
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdParticipationRejectPut(torrowId: kotlin.String, body: kotlin.String? = null): Participation {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/participation/reject".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<Participation>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Participation
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param userMessage  (optional)
     * @return Participation
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdParticipationRejectofferPut(torrowId: kotlin.String, body: kotlin.String? = null, userMessage: kotlin.String? = null): Participation {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("userMessage" to listOf("$userMessage"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/participation/rejectoffer".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<Participation>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Participation
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param userMessage  (optional)
     * @return Participation
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdParticipationRequestaccessPut(torrowId: kotlin.String, body: kotlin.String? = null, userMessage: kotlin.String? = null): Participation {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("userMessage" to listOf("$userMessage"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/participation/requestaccess".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<Participation>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Participation
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return ParticipationResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdParticipationRevokeofferPut(torrowId: kotlin.String, body: kotlin.Array<kotlin.String>? = null): ParticipationResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/participation/revokeoffer".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<ParticipationResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ParticipationResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @return Participation
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdParticipationRevokerequestPut(torrowId: kotlin.String): Participation {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/participation/revokerequest".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<Participation>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Participation
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return ParticipationResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdParticipationSharePut(torrowId: kotlin.String, body: ShareItemReq? = null): ParticipationResp {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/participation/share".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<ParticipationResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ParticipationResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdParticipationShareitemlinkPost(torrowId: kotlin.String, body: GetShareItemSessionReq? = null): kotlin.String {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/calendars/{torrowId}/participation/shareitemlink".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<kotlin.String>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdPublicityPut(torrowId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/publicity".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param checkVersion  (optional, default to false)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return CalendarItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdPut(torrowId: kotlin.String, body: CalendarItem? = null, checkVersion: kotlin.Boolean? = null, isNeedAnnouncement: kotlin.Boolean? = null): CalendarItem {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("checkVersion" to listOf("$checkVersion"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<CalendarItem>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CalendarItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @return Participation
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdSavetomindmapPut(torrowId: kotlin.String, body: SaveItemToMindMapReq? = null): Participation {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/savetomindmap".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<Participation>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Participation
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdShorturlPost(torrowId: kotlin.String): kotlin.String {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/api/v1/calendars/{torrowId}/shorturl".replace("{" + "torrowId" + "}", "$torrowId")
        )
        val response = request<kotlin.String>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdSolutiondataPut(torrowId: kotlin.String, body: SolutionData? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/solutiondata".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param itemType  (optional)
     * @param text  (optional)
     * @param minParticipantType  (optional)
     * @param operationType  (optional)
     * @param recursionDepth  (optional, default to 0)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @return kotlin.Array<kotlin.String>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdTagsGet(torrowId: kotlin.String, itemType: TorrowObjectType? = null, text: kotlin.String? = null, minParticipantType: ParticipantType? = null, operationType: OperationType? = null, recursionDepth: kotlin.Int? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null): kotlin.Array<kotlin.String> {
        val localVariableQuery: MultiValueMap = mapOf("itemType" to listOf("$itemType"), "text" to listOf("$text"), "minParticipantType" to listOf("$minParticipantType"), "operationType" to listOf("$operationType"), "recursionDepth" to listOf("$recursionDepth"), "take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/calendars/{torrowId}/tags".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<kotlin.String>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.String>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdTagsPut(torrowId: kotlin.String, body: kotlin.Array<kotlin.String>? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/tags".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param visibility  (optional)
     * @param take  (optional, default to 2147483647)
     * @param skip  (optional, default to 0)
     * @param lmfrom  (optional)
     * @param lmto  (optional)
     * @param includeDeleted  (optional, default to false)
     * @param sort  (optional)
     * @return kotlin.Array<TimetableCase>
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdTimetablePut(torrowId: kotlin.String, body: TimetableFilter? = null, visibility: TimetableDetailsVisibility? = null, take: kotlin.Int? = null, skip: kotlin.Int? = null, lmfrom: java.time.LocalDateTime? = null, lmto: java.time.LocalDateTime? = null, includeDeleted: kotlin.Boolean? = null, sort: ItemViewSortCondition? = null): kotlin.Array<TimetableCase> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("visibility" to listOf("$visibility"), "take" to listOf("$take"), "skip" to listOf("$skip"), "lmfrom" to listOf("$lmfrom"), "lmto" to listOf("$lmto"), "includeDeleted" to listOf("$includeDeleted"), "sort" to listOf("$sort"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/timetable".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<TimetableCase>>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<TimetableCase>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param versionToCheck  (optional, default to 0)
     * @param isNeedAnnouncement  (optional, default to false)
     * @return TorrowObject
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdTorrowaccountIdPut(torrowId: kotlin.String, body: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): TorrowObject {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/torrowaccount/id".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<TorrowObject>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TorrowObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param torrowId  
     * @param body  (optional)
     * @param parentId  (optional)
     * @param parentTags  (optional)
     * @param parentAlias  (optional)
     * @param tags  (optional)
     * @param alias  (optional)
     * @param versionToCheck  (optional)
     * @param isNeedAnnouncement  (optional, default to true)
     * @return IncludeExcludeResp
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsTorrowIdUpdategroupsPut(torrowId: kotlin.String, body: kotlin.Array<UpdateItemGroupsReq>? = null, parentId: kotlin.String? = null, parentTags: kotlin.Array<kotlin.String>? = null, parentAlias: kotlin.String? = null, tags: kotlin.Array<kotlin.String>? = null, alias: kotlin.String? = null, versionToCheck: kotlin.Int? = null, isNeedAnnouncement: kotlin.Boolean? = null): IncludeExcludeResp {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("parentId" to listOf("$parentId"), "parentTags" to toMultiValue(parentTags!!.toList(), "multi"), "parentAlias" to listOf("$parentAlias"), "tags" to toMultiValue(tags!!.toList(), "multi"), "alias" to listOf("$alias"), "versionToCheck" to listOf("$versionToCheck"), "isNeedAnnouncement" to listOf("$isNeedAnnouncement"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/api/v1/calendars/{torrowId}/updategroups".replace("{" + "torrowId" + "}", "$torrowId"), query = localVariableQuery
        )
        val response = request<IncludeExcludeResp>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as IncludeExcludeResp
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * 
     * @param uniquename  
     * @return CalendarItem
     */
    @Suppress("UNCHECKED_CAST")
    fun apiV1CalendarsUniquenameUniquenameGet(uniquename: kotlin.String): CalendarItem {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/api/v1/calendars/uniquename/{uniquename}".replace("{" + "uniquename" + "}", "$uniquename")
        )
        val response = request<CalendarItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CalendarItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
